#!/usr/bin/python
import sys
import re
import os
import logging
import importlib
import subprocess
import time
import inspect
import yaml
import shutil
import tempfile
from datetime import datetime
from copy import deepcopy
from threading import Thread
from Queue import Queue
from logging import FileHandler
from optparse import OptionParser
import psycopg2
from module_tools.myconfigparser import MyConfigParser
from module_tools import odoo_config
from module_tools.module_tools import set_ownership_exclusive

try:
    from pudb import set_trace
except Exception:
    set_trace = None
current_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) # script directory
sys.path.append(os.path.join(current_dir, 'python_wait'))
import wait

PLATFORM_OSX = "OSX"
PLATFORM_LINUX = "Linux"
YAML_VERSION = '3.3'
BACKUPDIR = "/host/dumps"

parser = OptionParser(
    description="""Odoo Administration Script
"""
)
parser.add_option(
    '-f', '--force', action='store_true', default=False, help="Force actions if asked"
)
parser.add_option(
    '--verbose', action='store_true', default=False,
)
parser.add_option(
    '--no-verbose', action='store_true', default=False,
)
(options, args) = parser.parse_args()

if options.verbose and options.no_verbose:
    print("Please set either verbose or not verbose.")
    sys.exit(1)

dirs = {
    'odoo_home': '',
    'proxy_configs_dir': 'run/proxy',
    'settings.d': 'run/settings.d',
    'host_working_dir': '',
    'run': 'run',
    'run/proxy': 'run/proxy',
    'run/restore': 'run/restore',
    'machines': 'machines',
    'machines/proxy': 'machines/proxy',
    'customs': '',
}

files = {
    'docker_compose': 'run/docker-compose.yml',
    'settings': 'run/settings',
    'odoo_instances': 'run/odoo_instances',
    'config/docker-compose.yml': 'config/docker-compose.yml',
    'run/odoo_debug.txt': 'run/odoo_debug.txt',
    'machines/proxy/odoo_instance.conf': 'machines/proxy/odoo_instance.conf',
}
commands = {
    'manage': 'admin/odoo-admin',
    'dc': "/usr/local/bin/docker-compose -p $CUSTOMS -f $docker_compose_file",
}


def trace():
    if set_trace:
        set_trace()

def _get_platform():
    if os.getenv("PLATFORM", "") in ['Darwin', 'OSX']:
        return PLATFORM_OSX
    else:
        return PLATFORM_LINUX

def _startup():
    dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) # script directory
    dir = os.path.dirname(dir)
    dirs['odoo_home'] = dir

    def make_absolute(d):
        for k, v in d.items():
            if not v.startswith('/'):
                d[k] = os.path.join(dir, v)
    make_absolute(dirs)
    make_absolute(files)
    make_absolute(commands)
    os.environ['ODOO_MANAGER_STARTED_ONCE'] = '1'
    os.environ['ODOO_COMPOSE_VERSION'] = "3.3"
    os.environ['PGPASSFILE'] = "/tmp/.pgpass" # must match the executing script
    os.environ['PGHOST'] = "$DB_HOST"
    os.environ['PGPORT'] = "$DB_PORT"
    os.environ['PGUSER'] = "$DB_USER"
    os.environ['LOCAL_WORKING_DIR'] = "{}/{}".format(os.getenv("EXTERNAL_ROOT"), os.getenv("WORKING_DIR"))  # the working directory accessible from container of this script.
    dirs['host_working_dir'] = os.environ['LOCAL_WORKING_DIR']

def _check_working_dir_customs_mismatch():
    # Checks wether the current working is in a customs directory, but
    # is not matching the correct customs. Avoid creating wrong tickets
    # in the wrong customizations.

    working_dir = dirs['host_working_dir']
    while not os.path.isfile(os.path.join(working_dir, '.customsroot')):
        try:
            working_dir = os.path.dirname(working_dir)
        except Exception:
            break
        if not working_dir.replace("/", ""):
            break

    if os.path.isfile(os.path.join(working_dir, '.customsroot')):
        current_customs = os.path.basename(working_dir)
        if current_customs != os.environ['CUSTOMS']:
            _askcontinue("""Caution: current customs is {} but you are in another customs directory: {}
Continue at your own risk!""".format("$CUSTOMS", "$LOCAL_WORKING_DIR")
                         )


def _askcontinue(msg=None):
    if msg:
        print(msg)
    if options.force or os.getenv("FORCE_CONTINUE", "0") == "1":
        return
    raw_input("Continue? (Ctrl+C to break)")

def _file2env(filepath):
    if not os.path.exists(filepath):
        return
    config = MyConfigParser(filepath)
    for k in config.keys():
        os.environ[k] = config[k]

def _collect_settings_files():
    files = []
    files.append(os.path.join(dirs['odoo_home'], 'machines/defaults'))
    for root, _, filenames in os.walk(dirs['machines']):
        for filename in filenames:
            if filename == 'default.settings':
                files.append(os.path.join(root, filename))
    customs_dir = odoo_config.customs_dir()
    if os.path.exists(os.path.join(customs_dir, 'settings')):
        files.append(os.path.join(customs_dir, 'settings'))
    if os.path.exists('/etc_host/odoo/settings'):
        files.append('/etc_host/odoo/settings')
    if os.path.exists('/etc_host/odoo/{}/settings'.format(os.environ['CUSTOMS'])):
        files.append('/etc_host/odoo/{}/settings'.format(os.environ['CUSTOMS']))
    if os.path.isdir(dirs['settings.d']):
        for filename in os.listdir(dirs['settings.d']):
            filepath = os.path.join(dirs['settings.d'], filename)
            if os.path.exists(filepath):
                files.append(filepath)
    return files

def _make_settings_file(outfile, setting_files):
    """
    Puts all settings into one settings file
    """
    c = MyConfigParser(outfile)
    for file in setting_files:
        if not file:
            continue
        c2 = MyConfigParser(file)
        c.apply(c2)
    c.write()

def _export_settings():
    if args and args[0] == 'compose':
        if len(args) > 1:
            customs = args[1]
            if os.path.isfile(files['settings']):
                os.unlink(files['settings'])
            config = MyConfigParser(files['settings'])
            config['CUSTOMS'] = customs
            config.write()
    _file2env(files['settings'])

    if not os.path.exists(files['settings']):
        raise Exception("Please call ./odoo compose <CUSTOMS> initially.")

    # get odoo version
    ODOO_VERSION = str(odoo_config.get_version_from_customs(os.environ['CUSTOMS']))
    os.environ['ODOO_VERSION'] = ODOO_VERSION
    if ODOO_VERSION in ["6.0", "6.1", "7.0", "8.0", "9.0"]:
        os.environ['ODOO_PYTHON_VERSION'] = '2'
        os.environ['ODOO_EXECUTABLE'] = 'openerp-server'
    elif ODOO_VERSION in ["10.0"]:
        os.environ['ODOO_PYTHON_VERSION'] = '2'
        os.environ['ODOO_EXECUTABLE'] = 'odoo-bin'
    elif ODOO_VERSION in ['11.0']:
        os.environ['ODOO_PYTHON_VERSION'] = '3'
        os.environ['ODOO_EXECUTABLE'] = 'odoo-bin'
    else:
        raise Exception("not impl: {}".format(ODOO_VERSION))

    setting_files = _collect_settings_files()
    _make_settings_file(files['settings'], setting_files)
    config = MyConfigParser(files['settings'])
    if "DBNAME" not in config.keys():
        config['DBNAME'] = config['CUSTOMS']
        config.write()
    # store the host root folder
    config['HOST_ODOO_HOME'] = E("ODOO_HOME")
    _file2env(files['settings'])

def docommand(cmd):
    out = subprocess.check_output(cmd, cwd=dirs['odoo_home'])
    return out

def dcexec(cmd):
    cmd = [commands['dc'], 'exec', '-T'] + cmd
    out = subprocess.check_output(cmd, cwd=dirs['odoo_home'])
    return out

def dc(cmd):
    cmd = [commands['dc']] + cmd
    out = subprocess.check_output(cmd, cwd=dirs['odoo_home'])
    return out

def dcrun(cmd):
    cmd = [commands['dc'], 'run', '--rm', '-T', '-e ODOO_HOME=/opt/odoo'] + cmd
    return dc(cmd)

def _remember_customs_and_cry_if_changed():
    # if customs changed, then restart is required

    out = dcexec(['odoo env'])
    out = [x for x in out.split('\n') if "CUSTOMS="]
    if out:
        current_customs = out[0].split("=")[-1]
        if current_customs != os.environ['CUSTOMS']:
            print("Customs changed - you need to restart and/or rebuild!")
            docommand(commands['manage'], 'kill')

def __restore_check(filepath):
    dumpname = os.path.basename(filepath)

    if E("DBNAME") not in dumpname or options.force:
        raise Exception("The dump-name \"$dumpname\" should somehow match the current database \"$DBNAME\", which isn't.")

def __exists_db():
    sql = "select count(*) from pg_database where datname='{}'".format(E("DBNAME"))
    record = __execute_sql(sql, fetchone=True)
    if not record or not record[0]:
        return False
    return True

def reset_postgres_container():
    # remove the postgres volume and reinit
    if E("RUN_POSTGRES") == "1":
        print "Resettings postgres - killing data - not reversible"
        do_command("kill")
        dc(["rm", "-f"]) # set volume free
        VOLUMENAME = "{}_postgresdata".format(E("CUSTOMS"))
        docker volume ls |grep -q "$VOLUMENAME" && docker volume rm "$VOLUMENAME"
        $MANAGE reset-db
        $MANAGE up -d postgres
        $MANAGE wait_for_container_postgres

def remove_postgres_connections():
    print "Removing all current connections"
    if __exists_db():
        SQL = """
            SELECT pg_terminate_backend(pg_stat_activity.pid)
            FROM pg_stat_activity
            WHERE pg_stat_activity.datname = '{}'
            AND pid <> pg_backend_pid();
        """.format(E("DBNAME"))
        __execute_sql(SQL)

"""




function do_restore_db_on_postgres () {
    SUFFIX="_restoring"
    DBNAME_TARGET="$DBNAME"
    DBNAME="${DBNAME}${SUFFIX}"
    export DBNAME="$DBNAME"
    dump_file=/host/dumps/$1
    set -e

    if [[ ! -e "$dump_file" ]]; then
        echo "File $dump_file not found!"
        exit 1
    fi

    echo "Restoring dump on $DB_HOST"
    echo "Using Host: $DB_HOST, Port: $DB_PORT, User: $DB_USER, ...."
    export PGPASSWORD=$DB_PWD
    local args="-h $DB_HOST -p $DB_PORT -U $DB_USER"
    DROPDB="dropdb $args"
    CREATEDB="createdb $args"
    PGRESTORE="pg_restore --no-owner --no-privileges --no-acl  --single-transaction --exit-on-error $args"
    PSQL="psql $args"

    eval "$DROPDB --if-exists $DBNAME" || echo "Failed to drop $DBNAME"
    eval "$CREATEDB $DBNAME"

    method="$PGRESTORE"
    needs_unzip=1
    gunzip -c "$dump_file" | head | grep -q PostgreSQL.database.dump && {
        method="$PSQL"
    }
    if [[ "$method" != "psql" ]]; then
        head "$dump_file" | grep -q PostgreSQL.database.dump && {
            needs_unzip=0
            method="$PSQL"
        }
    fi

    if [[ "$needs_unzip" == "1" ]]; then
        pipe=$(mktemp -u)
        mkfifo "$pipe"
        gunzip -c  "$dump_file" > "$pipe" &
    else
        pipe="$dump_file"
    fi
	echo "Restoring $DBNAME using $method..."
	$method -d "$DBNAME" < "$pipe"

    remove_postgres_connections
    sql=("
        SELECT pg_terminate_backend(pg_stat_activity.pid)
        FROM pg_stat_activity 
        WHERE pg_stat_activity.datname = '$DBNAME_TARGET' 
        AND pid <> pg_backend_pid(); 

        drop database if exists $DBNAME_TARGET;
        alter database $DBNAME rename to $DBNAME_TARGET;
        ")
    echo "${sql[0]}"| $MANAGE psql template1

    DBNAME="$DBNAME_TARGET"
    export DBNAME="$DBNAME"
    remove_postgres_connections

    return 0
}

function showhelp() {
    echo Management of odoo instance
    echo
    echo
    echo ./odoo sanity-check
    echo Reinit fresh db:
    echo './odoo reset-db'
    echo
    echo Update:
    echo './odoo update [module]'
    echo 'Just custom modules are updated, never the base modules (e.g. prohibits adding old stock-locations)'
    echo 'Minimal downtime - but there is a downtime, even for phones'
    echo 
    echo "Please call odoo springclean|update|backup|run_standalone|upall|attach_running|rebuild|restart"
    echo ""
    echo "abort-upgrade"
    echo ""
    echo "attach <machine> - attaches to running machine"
    echo ""
    echo "backup <backup-dir> - backup database and/or files to the given location with timestamp; if not directory given, backup to dumps is done "
    echo ""
    echo "backup-db <backup-dir>"
    echo ""
    echo "backup-files <backup-dir>"
    echo ""
    echo "debug <machine-name> - starts /bin/bash for just that machine and connects to it; if machine is down, it is powered up; if it is up, it is restarted; as command an endless bash loop is set"
    echo ""
    echo "dev - starts developing in the odoo container"
    echo ""
    echo "build - no parameter all machines, first parameter machine name and passes other params; e.g. ./odoo build asterisk --no-cache"
    echo ""
    echo "link - links all modules into ./links"
    echo ""
    echo "telegram-setup- helps creating a permanent chatid"
    echo ""
    echo "kill - kills running machines"
    echo ""
    echo "logs - show log output; use parameter to specify machine"
    echo ""
    echo "logall - shows log til now; use parameter to specify machine"
    echo ""
    echo "springclean - remove dead containers, untagged images, delete unwanted volums"
    echo ""
    echo "rm - command"
    echo ""
    echo "compose - just build the big docker-compose file"
    echo ""
    echo "rebuild - rebuilds docker-machines - data not deleted"
    echo ""
    echo "restart - restarts docker-machine(s) - parameter name"
    echo ""
    echo "restore <filepathdb> <filepath_tarfiles> [-force] - restores the given dump as odoo database"
    echo ""
    echo "restore-dev-db - Restores database dump regularly and then applies scripts to modify it, so it can be used for development (adapting mailserver, disable cronjobs)"
    echo ""
    echo "runbash <machine name> - starts bash in NOT RUNNING container (a separate one)"
    echo ""
    echo "setup-startup makes skript in /etc/init/${CUSTOMS}"
    echo ""
    echo "stop - like docker-compose stop"
    echo ""
    echo "quickpull - fetch latest source, oeln - good for mako templates"
    echo ""
    echo "turn-into-dev - applies scripts to make the database a dev database"
    echo ""
    echo "update <machine name>- fetch latest source code of modules and run update of just custom modules; machines are restarted after that"
    echo ""
    echo "up - starts all machines equivalent to service <service> start "
    echo ""
    echo "remove-web-assets - if odoo-web interface is broken (css, js) then purging the web-assets helps; they are recreated on odoo restart"
    echo ""
    echo "fix-permissions - sets user 1000 for odoo and odoo_files"
    echo ""
    echo "show-install-state "
    echo ""
    echo "make-customs"
    echo
    echo "patch - run without arguments for help"
    echo ""
    echo "version - run without arguments for help"
    echo ""
}

if [ -z "$1" ]; then
    showhelp
    exit -1
fi




function display_machine_tips() {
    cd "$DIR"
    tipfile=$(find "machines" -name 'tips.txt' | grep -P "\/$1\/" | while read -r file; do
        echo "$DIR/$file"
    done)
    if [[ -f "$tipfile" ]]; then
        echo 
        echo Please note:
        echo ---------------
        echo
        cat "$tipfile"
        echo 
        echo
    fi

    return 0
}

function awk() {
    AWK=$(which awk)
    command "${AWK:-awk}" "$@";
    return 0
}


"""
def E(name):
    if name.startswith("$"):
        name = name[1:]
    return os.getenv(name, "")

def __file_default_content(path, default_content):
    if not os.path.exists(path):
        with open(path, 'w') as f:
            f.write(default_content)

def _remove_temp_directories():
    for dir in os.listdir(dirs['odoo_home']):
        if dir.startswith("tmp") and len(dir) == len('tmp......'):
            __rmtree(os.path.join(dirs['odoo_home'], dir))

def __makedirs(path):
    if not os.path.exists(path):
        os.makedirs(path)

def _prepare_filesystem():
    __makedirs(dirs['settings.d'])
    for subdir in ['config', 'sqlscripts', 'debug', 'proxy']:
        __makedirs(os.path.join(dirs['odoo_home'], 'run', 'subdir'))
    subprocess.check_call(['sudo', '-E', 'chown', "{uid}:{uid}".format(uid=E("UID")), "-R", dirs['run']])

    __file_default_content(files['odoo_instances'], "default default\n")

def _prepare_yml_files_from_template_files():
    # replace params in configuration file
    # replace variables in docker-compose;

    if E("ODOO_MANAGER_STARTED_ONCE") != "1":
        for name in ['CUSTOMS', 'DB', 'ODOO_VERSION', 'ODOO_FILES']:
            print("{}: {}".format(name, E(name)))

    # python: find all configuration files from machines folder; extract sort
    # by manage-sort flag and put file into run directory
    # only if RUN_parentpath like RUN_ODOO is <> 0 include the machine
    #
    # - also replace all environment variables
    def find_files(dir):
        PATTERN = r'docker-compose*.yml'
        for root, _, filenames in os.walk(dirs['machines']):
            for filename in filenames:
                if re.findall(PATTERN, filename):
                    yield os.path.join(root, filename)
    _files = []
    _files += find_files(dirs['machines'])
    _files += find_files(odoo_config.customs_dir())

    __prepare_docker_compose_files(files['docker_compose'], _files)

def __get_docker_image():
    hostname = os.environ['HOSTNAME']
    result = [x for x in subprocess.check_output(["/opt/docker/docker", "inspect", hostname]).split("\n") if "\"Image\"" in x]
    if result:
        result = result[0].split("sha256:")[-1].split('"')[0]
        return result[:12]
    raise Exception("Image not determined")

def get_run_command():
    """
    Returns bash ready command to call simplebash self by run.

    """
    host_odoo_home = os.environ["ODOO_HOME"]
    local_odoo_home = os.environ['LOCAL_ODOO_HOME']
    cmdline = []
    cmdline.append("/opt/docker/docker")
    cmdline.append("run")
    cmdline.append('-e')
    cmdline.append('ODOO_HOME={}'.format(host_odoo_home))
    envfile = os.path.join(local_odoo_home, 'run/settings')
    if os.path.exists(envfile):
        cmdline.append('--env-file')
        cmdline.append(envfile)
    cmdline.append("--rm")
    cmdline.append('-v')
    cmdline.append("{HOST_ODOO_HOME}:{HOST_ODOO_HOME}".format(HOST_ODOO_HOME=os.environ["ODOO_HOME"]))
    cmdline.append("--workdir")
    cmdline.append(host_odoo_home)
    cmdline.append(__get_docker_image())
    return cmdline

def __prepare_docker_compose_files(dest_file, paths):
    local_odoo_home = os.environ['LOCAL_ODOO_HOME']

    temp_files = set()
    tempdir = tempfile.mkdtemp()

    if not dest_file:
        raise Exception('require destination path')

    with open(dest_file, 'w') as f:
        f.write("#Composed {}\n".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        f.write("version: '{}'\n".format(os.environ['ODOO_COMPOSE_VERSION']))

    def replace_all_envs_in_file(filepath):
        with open(filepath, 'r') as f:
            content = f.read()
        all_params = re.findall(r'\$\{[^\}]*?\}', content)
        for param in all_params:
            name = param
            name = name.replace("${", "")
            name = name.replace("}", "")
            if name in os.environ:
                content = content.replace(param, os.environ[name])
        with open(filepath, 'w') as f:
            f.write(content)

    for path in set(paths):
        filename = os.path.basename(path)

        def use_file():
            if 'run_' in filename:
                run = re.findall(r'run_[^\.]*', filename)
                if run:
                    if os.getenv(run[0].upper(), "1") == "1":
                        return True
                return False
            else:
                return True

        if not use_file():
            continue

        with open(path, 'r') as f:
            content = f.read()
            # dont matter if written manage-order: or manage-order
            if 'manage-order' not in content:
                order = '99999999'
            else:
                order = content.split("manage-order")[1].split("\n")[0].replace(":", "").strip()
        folder_name = os.path.basename(os.path.dirname(path))
        if os.getenv("RUN_{}".format(folder_name.upper()), "1") == "0":
            continue

        order = str(order)

        # put all files in their order into the temp directory
        counter = 0
        temp_path = ""
        while not temp_path or os.path.exists(temp_path):
            counter += 1
            temp_path = os.path.join(tempdir, '{}-{}'.format(order, str(counter).zfill(5)))

        with open(temp_path, 'w') as dest:
            with open(path, 'r') as source:
                j = yaml.load(source.read())
                # TODO complain version - override version
                j['version'] = YAML_VERSION

                # set settings environment and the override settings after that
                for file in ['run/settings']:
                    path = os.path.join(local_odoo_home, file)
                    if os.path.exists(path):
                        if 'services' in j:
                            for service in j['services']:
                                service = j['services'][service]
                                if 'env_file' not in service:
                                    service['env_file'] = []
                                if isinstance(service['env_file'], (str, unicode)):
                                    service['env_file'] = [service['env_file']]

                                if not [x for x in service['env_file'] if x == '$ODOO_HOME/{}'.format(file)]:
                                    service['env_file'].append('$ODOO_HOME/{}'.format(file))

                dest.write(yaml.dump(j, default_flow_style=False))
                dest.write("\n")
        replace_all_envs_in_file(temp_path)
        temp_files.add(os.path.basename(temp_path))
        del temp_path

    def post_process_complete_yaml_config(yml):
        """
        This is after calling docker-compose config, which returns the
        complete configuration.

        Aim is to take the volumes defined in odoo_base and append them
        to all odoo containers.
        """

        with open(os.path.join(local_odoo_home, 'machines/odoo/docker-compose.yml')) as f:
            odoodc = yaml.load(f.read())

        for odoomachine in odoodc['services']:
            if odoomachine == 'odoo_base':
                continue
            machine = yml['services'][odoomachine]
            for k in ['volumes']:
                machine[k] = []
                for x in yml['services']['odoo_base'][k]:
                    machine[k].append(x)
            for k in ['environment']:
                machine.setdefault(k, {})
                for x, v in yml['services']['odoo_base'][k].items():
                    machine[k][x] = v
        yml['services'].pop('odoo_base')

        return yml


# call docker compose config to get the complete config
    files = sorted(temp_files, key=lambda x: float(x.split("/")[-1].replace("-", ".")))
    cmdline = get_run_command()
    cmdline.append("/usr/local/bin/docker-compose")
    for file in files:
        cmdline.append('-f')
        cmdline.append(os.path.join(os.path.basename(tempdir), file))
    cmdline.append('config')

# annotation: per symlink all subfiles/folders are linked to a path,
# that matches the host system path
    shutil.move(tempdir, local_odoo_home)
    tempdir = os.path.join(local_odoo_home, os.path.basename(tempdir))

    try:
        proc = subprocess.Popen(cmdline, cwd=local_odoo_home, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        conf, err = proc.communicate()
        if err:
            print "==================================================================="
            print "command line: "
            for x in cmdline:
                print x
            print "==================================================================="
            print err
            print "==================================================================="
            raise Exception(err)
    except Exception:
        print cmdline
        raise
    else:
        # post-process config config
        conf = post_process_complete_yaml_config(yaml.load(conf))
        conf = yaml.dump(conf, default_flow_style=False)

        with open(dest_file, 'w') as f:
            f.write(conf)
    finally:
        __rmtree(tempdir)

def __empty_dir(dir):
    if os.path.isdir(dir):
        for f in os.listdir(dir):
            filepath = os.path.join(dir, f)
            if os.path.isdir(filepath):
                __rmtree(filepath)
            else:
                os.unlink(filepath)

def _reset_proxy_configs():
    __empty_dir(dirs['run/proxy'])

def _setup_proxy():
    CONFIG_DIR = dirs['run/proxy']

    sys.path.append(dirs['machines/proxy'])
    importlib.import_module("add_upstream")
    from add_upstream import add_upstream as f_add_upstream

    def get_rules():
        for root, _, filenames in os.walk(dirs['machines']):
            for filename in filenames:
                if filename == 'upstream.path':
                    filepath = os.path.join(root, filename)
                    with open(filepath, 'r') as f:
                        for l in f.readlines():
                            if l:
                                yield filepath, l

    for filepath, rule in get_rules():
        rule = os.path.expandvars(rule)

        LOCATION, UPSTREAM = rule.strip().split(" ")

        if not LOCATION or not UPSTREAM:
            raise Exception("Invalid rule: {}".format(rule))

        parent_dir = os.path.dirname(filepath)
        if os.path.basename(parent_dir) == "odoo":
            subdir = "odoo"
            __makedirs(os.path.join(CONFIG_DIR, subdir))

            if os.path.exists(files['odoo_instances']):
                for line in __file_get_lines(files['odoo_instances']):
                    name, domain = line.strip().split(" ")
                    filename = "{}.location".format(name)
                    CONFIG_PATH = os.path.join(CONFIG_DIR, subdir, filename)
                    if name == "default":
                        UPSTREAM_INSTANCE = UPSTREAM.replace("default", "odoo")
                    else:
                        UPSTREAM_INSTANCE = UPSTREAM.replace("odoo", "odoo_{}".format(name))
                    f_add_upstream(LOCATION, UPSTREAM_INSTANCE, CONFIG_PATH)

        else:
            subdir = "default"
            __makedirs(os.path.join(CONFIG_DIR, subdir))
            safe_location = LOCATION.replace("\\", "_").replace("/", "")
            filename = "{location}_{location}.location".format(location=safe_location)
            CONFIG_PATH = os.path.join(CONFIG_DIR, subdir, filename)
            f_add_upstream(LOCATION, UPSTREAM, CONFIG_PATH)

def __file_get_lines(path):
    with open(path) as f:
        return f.readlines()

def __replace_in_file(filepath, text, replacewith):
    with open(filepath, 'r') as f:
        content = f.read()
    content = content.replace(text, replacewith)
    with open(filepath, 'w') as f:
        f.write(content)

def _setup_odoo_instances():
    if os.path.exists(files['odoo_instances']):
        __empty_dir(dirs['proxy_configs_dir'])

        if os.path.exists(files['odoo_instances']):
            for line in __file_get_lines(files['odoo_instances']):
                name, domain = line.strip().split(" ")
                config_path = os.path.join(dirs['proxy_configs_dir'], "{}.host".format(name))
                shutil.copy(files['machines/proxy/odoo_instance.conf'], config_path)
                if domain == "default":
                    __replace_in_file(config_path, "__DOMAIN__", "*")
                else:
                    if domain:
                        __replace_in_file(config_path, "__DOMAIN__", domain)
            if name:
                __replace_in_file(config_path, "__CONTAINERNAME__", name)

            if name != "default":
                # adapt the one yml file and duplicate the odoo service there;
                # removing any ports
                with open(files['docker_compose_file']) as f:
                    j = yaml.load(f.read())
                odoo = deepcopy(j['services']['odoo'])
                if 'ports' in odoo:
                    del odoo['ports']
                odoo['container_name'] = '_'.join([os.environ['CUSTOMS'], "odoo", name])
                j['services']['odoo_{}'.format(name)] = odoo
                with open(files['docker_compose_file'], 'w') as f:
                    f.write(yaml.dump(j, default_flow_style=False))

def _sanity_check():
    if not E("RUN_POSTGRES"):
        raise Exception("Please define RUN_POSTGRES")

    if E("RUN_POSTGRES") == "1" and E("DB_HOST") != "postgres":
        print("You are using the docker postgres container, but you do not have the DB_HOST set to use it.")
        print("Either configure DB_HOST to point to the docker container or turn it off by: ")
        print("RUN_POSTGRES=0")
        sys.exit(1)

    if E("OWNER_UID") == "0":
        print("Advise: you should set OWNER_UID so that dump files are marked as the correct owner")
        time.sleep(3)

    if E("RUN_POSTGRES") == "1":
        if os.path.isdir(dirs['run/restore']):
            __try_to_set_owner(E("OWNER_UID"), dirs['run/restore'])

    if E("ODOO_FILES") and os.path.isdir(E("ODOO_FILES")):
        # checking directory permissions of session files and filestorage
        __try_to_set_owner(E("OWNER_UID"), E("$ODOO_FILES"))

    # make sure the odoo_debug.txt exists; otherwise directory is created
    __file_default_content(files['run/odoo_debug.txt'], "")

    if not E("ODOO_MODULE_UPDATE_RUN_TESTS"):
        print("Please define wether to run tests on module updates by setting ODOO_MODULE_UPDATE_RUN_TESTS")
        time.sleep(2)


def __rm_file_if_exists(path):
    if os.path.exists(path):
        os.unlink(path)

def _cleanup():
    __rm_file_if_exists(files['config/docker-compose.yml'])
    _remove_temp_directories

def __try_to_set_owner(UID, path):
    if os.path.isdir(path):
        uid = os.stat(path).st_uid
        if str(uid) != str(UID):
            print("Trying to set correct permissions on $dir")
            os.system("chown {} '{}'".format(UID, path))

def __start_postgres_and_wait():
    if E("RUN_POSTGRES") == "1":
        dc(["up", "-d", "postgres"])
        __wait_for_port('postgres', 5432)

def __set_db_ownership():
    # in development environments it is safe to set ownership, so
    # that accidently accessing the db fails
    if E("DEVMODE") == "1":
        if E("RUN_POSTGRES") == "1":
            __start_postgres_and_wait()
        set_ownership_exclusive()

def __wait_for_port(host, port, timeout=None):
    res = wait(port, host=host, timeout=timeout)
    if not res and timeout:
        raise Exception("Timeout elapsed waiting for {}:{}".format(host, port))

def __rmtree(path):
    if not path or path == '/':
        raise Exception("Not allowed: {}".format(path))
    if not path.startswith("/"):
        raise Exception("Not allowed: {}".format(path))
    if not any(path.startswith(dirs['odoo_home'] + x) for x in ['/tmp', '/run/']):
        raise Exception('not allowed')
    shutil.rmtree(path)

def __execute_sql(sql, dbname=None, fetchone=False):
    if not dbname:
        dbname = E("DBNAME")
    conn = psycopg2.connect(
        dbname=dbname,
        user=E("DB_USER"),
        password=E("DB_PWD"),
        host=E("DB_HOST"),
        port=E("DB_PORT")
    )
    result = None
    cr = conn.cursor()
    try:
        cr.execute(sql)
        if fetchone:
            result = cr.fetchone()
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        cr.close()
        conn.close()
    return result

def do_command(command, command_parameters=[]):
    if not command:
        return

    if command == "abort-upgrade":
        SQL = """
            UPDATE ir_module_module SET state = 'installed' WHERE state = 'to upgrade';
            UPDATE ir_module_module SET state = 'uninstalled' WHERE state = 'to install';
        """
        __execute_sql(SQL)

    elif command == "setup-startup":
        if os.path.exists("/sbin_host/initctl"):
            raise Exception("Not impl")
        else:
            print "Setting up systemd script for startup"
            servicename = os.path.expandvars("${CUSTOMS}_odoo.service")
            file = os.path.join("/tmp_host, servicename")

            # echo "Setting up upstart script in $file"
            shutil.copy(os.path.join(dirs['odoo_home'], 'config', 'systemd'), file)
            __replace_in_file(file, "${CUSTOMS}", E("CUSTOMS"))
            __replace_in_file(file, "${PATH}", E("HOST_ODOO_HOME"))

            print("Please execute on host now (perhaps as sudo):")
            print("""cp /tmp/{servicename} /etc/systemd/system")
            systemctl stop {servicename}
            systemctl disable {servicename}
            systemctl daemon-reload
            systemctl reset-failed
            systemctl enable {servicename}
            systemctl start {servicename}
            """.format(servicename=servicename)
                  )
    elif command == 'exec':
        dcexec(command_parameters)

    elif command == "backup-db":
        if command_parameters:
            filename = command_parameters[0]
        else:
            filename = datetime.now().strftime("{} %Y-%m-%d_%H%M%S.dump.gz".format(E("CUSTOMS")))

        if filename.startswith("/"):
            raise Exception("No slash for backup filename allowed")
        print "Databasename is " + E("DBNAME")
        filepath = os.path.join(BACKUPDIR, filename)
        if os.path.exists(filepath):
            os.unlink(filepath)
        LINKPATH = os.path.join(BACKUPDIR, 'latest_dump')
        __start_postgres_and_wait()
        os.system('pg_dump -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -Z0 -Fc "$DBNAME" | pigz --rsyncable > "{}"'.format(filepath))
        if E("NO_BACKUP_SYMBOLIC_LINK_DUMP") != "1":
            if os.path.exists(LINKPATH):
                os.unlink(LINKPATH)
            os.symlink(filepath, LINKPATH)
        print "Dumped to ", filepath
        __telegram_send("Database Backup $DBNAME done to $filepath")

    elif command == "backup-files":
        if command_parameters:
            raise Exception("No parameters allowed")
        BACKUP_FILENAME = "{CUSTOMS}.files.tar.gz".format(CUSTOMS=E("CUSTOMS"))

        if os.path.exists(BACKUP_FILEPATH):
            second = BACKUP_FILEPATH + ".bak"
            if os.path.exists(second):
                os.unlink(second)
            shutil.move(BACKUP_FILEPATH, second)
        dcrun(["odoo", "/backup_files.sh", BACKUP_FILENAME])
        print "Backup files done to {}".format(BACKUP_FILENAME)

    elif command == backup:
        manage(["backup-db"])
        manage(["backup-files"])

    elif command == 'reset-db':
        _askcontinue("Delete database {}".format(E("DBNAME")))
        if E("RUN_POSTGERS") != "1":
            print "Postgres container is disabled; cannot reset external database"
            return
        print "Stopping all services and creating new database"
        print "After creation the database container is stopped. You have to start the system up then."
        dc(['kill'])
        dcrun(['-e INIT=1', 'postgres', '/entrypoint2.sh'])
        print "Database initialized."

    elif command == "restore-files":
        dumpfile = command_parameters[0]
        if not command_parameters:
            raise Exception("Please provide the tar file-name.")
        __do_restore_files("$dumpfile")

    elif command == "restore-db":
        for x in ["DB_HOST", "DB_PORT"]:
            print("{}: {}".format(x, E(x)))
        dumpfile = command_parameters[1]
        if dumpfile.startswith("/"):
            raise Exception("No path in dump file allowed")
        __restore_check(dumpfile)
        if [[ "$DEVMODE" == "1" && "$RESTORE_DEV_DB" != "1" ]]; then
            _askcontinue("DEVMODE ist set - really restore as normal db? Not using restore-dev-db?")

        if not options.force:
            _askcontinue("Deletes database {}!".format(E("DBNAME")))
        }

        __reset_postgres_container()
        do_restore_db_on_postgres "$dumpfile"

		remove_postgres_connections
		__set_db_ownership
		$MANAGE telegram-send "Database Restore $DBNAME done."

		;;
    elif command == "set_db_ownership":
        __set_db_ownership()
		;;

    elif command == "proxy-reload":
        local ok
        ok=xxxx
        [$dc ps -q proxy ] && {
            dcexec proxy /opt/bin/hot_reload.sh
        } || {
            :
        }
		;;

    elif command == "restore-dev-db":
        if [[ "$ALLOW_RESTORE_DEV" ]]; then
                echo "ALLOW_RESTORE_DEV must be explicitly allowed."
                exit -1
        fi
        echo "Restores dump to $DB_HOST and executes to scripts to adapt user passwords, mailservers and cronjobs"
		export RESTORE_DEV_DB=1
		set +e
		$MANAGE restore-db "${ALL_PARAMS[@]}" || true # ignore restore errors like not found user and so
		$MANAGE turn-into-dev "${ALL_PARAMS[@]}"

        ;;
    elif command == "turn-into-dev"
		if [[ "$DEVMODE" != "1" ]]; then
			echo "When applying this sql scripts, the database is not usable anymore for production environments. "
			echo "Please set DEVMODE=1 to allow this"
			exit -1
		fi
        SQLFILE=machines/postgres/turndb2dev.sql
		$MANAGE psql "$DBNAME" < $SQLFILE
		
		;;
    elif command == "psql":
		# gets sql query from pipe
		# check if there is a pipe argument
		local query=""
		if [[ ! -t 0 ]]; then  # checks if there is pipe data https://unix.stackexchange.com/questions/33049/check-if-pipe-is-empty-and-run-a-command-on-the-data-if-it-isnt
			query="$(cat /dev/stdin)"
		fi	

		if [[ "$RUN_POSTGRES" == "1" ]]; then
			$dc up -d postgres
			$MANAGE wait_for_container_postgres
            SQLFILE="$DIR/run/sqlscripts/script.sql"
            echo "$query" | tee "$SQLFILE"

            dcexec postgres gosu postgres psql "${ALL_PARAMS[*]}" -U "$DB_USER" -f "/opt/sqlscripts/$(basename "$SQLFILE")"
            rm "$SQLFILE"
		else
			export PGPASSWORD=$DB_PWD
			echo "$query" | psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -w "${ALL_PARAMS[@]}"
		fi 
		;;

    elif command == "springclean":
        docker system prune

        echo removing dead containers
		docker ps -a -q | while read -r id; do
			docker rm "$id"
		done

        echo Remove untagged images
        docker images | grep "<none>" | awk '{ print "docker rmi " $3 }' | bash

        echo "delete unwanted volumes (can pass -dry-run)"
		docker images -q -f='dangling=true' | while read -r id; do
			docker rmi "$id"
		done
        ;;
    elif command == "up":
        __set_db_ownership()
        $dc up "${ALL_PARAMS[@]}"
		$MANAGE proxy-reload
        ;;
    elif command == "debug":
		# puts endless loop into container command and then attaches to it;
		# by this, name resolution to the container still works
        if [[ -z "$2" ]]; then
            echo "Please give machine name as second parameter e.g. postgres, odoo"
            exit -1
        fi
		set_db_ownership
        echo "Current machine $2 is dropped and restartet with service ports in bash. Usually you have to type /debug.sh then."
        askcontinue
        # shutdown current machine and start via run and port-mappings the replacement machine
		$MANAGE kill "$2"
        cd "$DIR"
		DEBUGGING_COMPOSER=$DIR/run/debugging.yml
		cp "$DIR/config/debugging/template.yml" "$DEBUGGING_COMPOSER"
		sed -i -e "s/\${CUSTOMS}/$CUSTOMS/" -e "s/\${NAME}/$2/" "$DEBUGGING_COMPOSER"
		dc="$dc -f $DEBUGGING_COMPOSER"  # command now has while loop

        #execute self
		$dc up -d "$2"
		$MANAGE attach "$2"

        ;;
    elif command == "attach":
        if [[ -z "$2" ]]; then
            echo "Please give machine name as second parameter e.g. postgres, odoo"
            exit -1
        fi
		display_machine_tips "$2"
        $dc exec "$2" bash
        ;;
    elif command == "run":
		set_db_ownership
        $dc run "${ALL_PARAMS[@]}"
		;;
    elif command == "runbash":
        if [[ -z "$2" ]]; then
            echo "Please give machine name as second parameter e.g. postgres, odoo"
            exit -1
        fi
		set_db_ownership
		display_machine_tips "$2"
        $dc run --rm "$2" bash
        ;;
    elif command == "rebuild":
        cd "$DIR"
        $dc build --no-cache "${ALL_PARAMS[@]}"
        ;;
    elif command == "build":
        cd "$DIR"
        $dc build "${ALL_PARAMS[@]}"
        ;;
	force-kill)
		if [[ -z "$2" ]]; then
			echo "Please provide machine name."
			exit 1
		fi
        eval "$dc kill $2"
		;;
    elif command == "kill":
        cd "$DIR"
		if [[ -z "$2" ]]; then
			eval "$dc stop -t 20 redis"  # persist data
			if [[ "$RUN_POSTGRES" == "1" ]]; then
				eval "$dc stop -t 20 postgres"
			fi
		fi
		eval "$dc stop -t 10 $2 $3 $4 $5 $6 $7 $8 $9"
        ;;
    elif command == "stop"
        cd "$DIR"
        eval "$dc stop $2 $3 $4"
        ;;
    elif command == "logsn":
        cd "$DIR"
        eval "$dc logs --tail=$2 -f -t $3 $4"
        ;;
    elif command == "logs":
        cd "$DIR"
        lines="${ARGS[-1]}"
        if [[ -n ${lines//[0-9]/} ]]; then
            lines="5000"
        else
            echo "Showing last $lines lines"
        fi
        eval "$dc logs --tail=$lines -f -t $2 "
        ;;
    elif command == "logall":
        cd "$DIR"
        eval "$dc logs -f -t $2 $3"
        ;;
    elif command == "rm":
        cd "$DIR"
        $dc rm "${ALL_PARAMS[@]}"
        ;;
    elif command == "restart":
        cd "$DIR"
        eval "$dc stop $2"
        eval "$dc rm -f $2"
        eval "$dc up --force-recreate -d $2"
        $MANAGE proxy-reload
        ;;

    elif command == "dev":
        if [[ -n "${ALL_PARAMS[0]}" ]]; then
            $MANAGE compose "${ALL_PARAMS[@]}"
        fi
        $MANAGE kill
        $MANAGE rm -f
        $MANAGE build
        $MANAGE up -d
        $MANAGE attach odoo
        ;;

    elif command == "telegram-setup":
        if [[ "$TELEGRAM_ENABLED" == "1" ]]; then
            export DIR="$DIR"
            cd "$DIR"/config/telegrambot
            docker-compose run telegrambot /setup.sh
        fi
        ;;

    elif command == "telegram-send":
        if [[ "$TELEGRAM_ENABLED" == "1" ]]; then
            export DIR="$DIR"
            cd "$DIR"/config/telegrambot
            docker-compose run telegrambot /send.py "$2"
        fi
        ;;
    elif command == "fix-permissions":
        if [[ -d "$ODOO_FILES" && -n "$ODOO_FILES" ]]; then
            chown "1000" -R "$ODOO_FILES"
        fi
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        if [[ -d "$CUSTOMS_DIR" && -n "$CUSTOMS_DIR" ]]; then
            chown "$USER" -R "$CUSTOMS_DIR"
        fi

        ;;
    elif command == "update":

        $MANAGE abort-upgrade

        echo "Run module update"
        if [[ -n "$ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER" ]]; then
            date +%s > "$ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER"
        fi
        # running duplicate updates is really a problem;
        $dc kill 
        $dc rm -f
        $dc create --force-recreate
        if [[ "$RUN_POSTGRES" == "1" ]]; then
            $dc up -d postgres
            $MANAGE wait_for_container_postgres
        fi

        dcrun odoo_update /update_modules.sh "$2" || {
            res="$?"
            echo "Error at /update_modules.sh - aborting update process."
            exit $res
        }
        $MANAGE show-install-state || exit 34

        for i in $(seq 5);
        do
            $dc up -d
            $MANAGE proxy-reload
            sleep 2
        done

        df -h / # case: after update disk / was full
        if [[ -n "$ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER" ]]; then
            echo '0' > "$ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER"
        fi
        $MANAGE telegram-send "Update done" # &> /dev/null

       ;;

    elif command == "show-install-state":
        SQL=$(cat <<-EOF
            SELECT name, state from ir_module_module where state not in ('installed', 'uninstalled');
EOF
            )
        echo "Displaying dangling modules:"
        echo "$SQL" | $MANAGE psql "$DBNAME"

        has_dangling=$(echo "$SQL" | $MANAGE psql "$DBNAME" | grep "(0 rows)")
        if [[ -z "$has_dangling" ]]; then
            echo "Dangling modules detected - please fix installation problems and retry!"
            exit -32
        fi
        ;;

    elif command == "get_all_langs":
        SQL="select code from res_lang;"
        langs=$(echo "$SQL" | $MANAGE psql --tuples-only "$DBNAME")
        echo $langs
        ;;

    elif command in ["export-i18n", "export_i18n"]:
        LANG=$2
        MODULES=$3
        if [[ -z "$MODULES" ]]; then
            echo "Syntax: export-i18n LANG MODULES"
            exit -1
        fi
        dcrun odoo /export_i18n.sh "$LANG" "$MODULES"
        # file now is in $DIR/run/i18n/export.po
        ;;

    elif command == "import-i18n":
        dcrun odoo /import_i18n.sh "${ALL_PARAMS[@]}"
        ;;

    elif command == "remove-web-assets":
        askcontinue
        dcrun odoo bash -c "cd ./admin/module_tools; python -c'from module_tools import remove_webassets; remove_webassets()'"
        echo
        echo
        echo "Please login as admin, so that assets are recreated."
        echo
        echo
        echo
        ;;
    elif command == "sanity_check":
        sanity_check
        ;;
    elif command == "make_customs":
        set -e
        askcontinue
        $MANAGE kill
        CUSTOMS=$2
        VERSION=$3
        "$DIR/admin/module_tools/make_customs" "$2" "$3"
        cd "$DIR/admin/module_tools"
        python <<- END
import odoo_config
odoo_config.set_customs("$2")
END

        cd "$DIR/customs/$2"
        git submodule add https://github.com/odoo/odoo odoo
        cd odoo
        git checkout "$VERSION"
        "$DIR/admin/OCA-all"
        "$DIR/admin/odoo-submodule tools,web_modulesroduct_modules,calendar_ics"
        "$DIR/$MANAGE" up -d
        chromium-browser http://localhost

        ;;
    elif command == "OCA":
        "$DIR/admin/OCA" "${ALL_PARAMS[@]}"
        ;;
    elif command == "compose":
        echo "Built the docker-compose file."
        ;;
    elif command == "simplebash":
        if [[ "${#ALL_PARAMS[@]}" == "0" ]]; then
            bash --noprofile
        else
            bash --noprofile -c "${ALL_PARAMS[*]}"
        fi
        ;;
    elif command == "test":
        echo 'reached the command area'
        echo "DIR is: $DIR"
        echo "CUSTOMS is: $CUSTOMS"
        sudo echo "This was sudoed"
        echo "Here is pgpassfile: $PGPASSFILE"
        echo "Now calling simple psql"
        SQL=$(cat <<-'            EOF'
            select state, count(*) from ir_module_module group by state;
            EOF
            )
        echo "$SQL" | $MANAGE psql "$DBNAME"
        ;;
    elif command == "test_make_error"
        echo "now throwing exit code"
        exit -123
        ;;
    elif command == "progress":
        SQL=$(cat <<-EOF
            select state, count(*) from ir_module_module group by state;
EOF
            )
        echo "$SQL" | $MANAGE psql "$DBNAME"

        ;;
    elif command == "prepare":
        echo "All configurations prepared."
        ;;
    elif command == "link":
        python "$DIR/admin/link_modules"
        ;;

    elif command == "patch":
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR/odoo" || exit 1
        cmd=("$DIR/admin/odoo-patch")
        cmd+=("${ALL_PARAMS[@]}")
        eval "${cmd[@]@Q}"
        ;;
    elif command == "wait_for_port":
        host = command_parameters[0]
        port = long(command_parameters[1])
        __wait_for_port(host=host, port=port)

    elif command == "wait_for_container_postgres":
        __start_postgres_and_wait()

    elif command == "dirty":
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=("dirty")
        eval "${cmd[@]@Q}"
        ;;
    elif command == "stage":
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=("stage-ticket")
        cmd+=( "${ALL_PARAMS[@]}" )
        eval "${cmd[@]@Q}"
        ;;
    elif command == "deploy":
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=("deploy-ticket")
        cmd+=( "${ALL_PARAMS[@]}" )
        eval "${cmd[@]@Q}"
        ;;
    elif command == "versioning":
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=( "${ALL_PARAMS[@]}" )
        eval "${cmd[@]@Q}"
        ;;
    elif command in ["new-ticket","switch-ticket","mergeto","deploy-ticket","stage-ticket","commit","incversions","current-ticket","open-tickets"]
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=("$1")
        cmd+=( "${ALL_PARAMS[@]}" )
        eval "${cmd[@]@Q}"
        ;;

    elif command == pull:
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR" || exit -1

        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Please provide the submodule name."
            exit -1
        fi
        if [[ ! -d ".git" ]]; then
            echo "No local git repo - where are you?"
            exit -1
        fi

        module="${ALL_PARAMS[0]}"
        git subtree pull --message "SUBTREE-PULL $module" --prefix="common/$module" --squash git.mt-software.de:"/git/openerp/modules/$module" master
        ;;

    elif command == "pull-all"
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR" || exit -1

        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Please provide the submodule name."
            exit -1
        fi
        if [[ ! -d ".git" ]]; then
            echo "No local git repo - where are you?"
            exit -1
        fi

        all_trees=$(git log | grep git-subtree-dir | awk '{ print $2 }') # | awk '{ split($0,a,"/"); print a[2]}')
        readarray -t all_tres <<<"$all_trees"

        for tree in "${all_tres[@]}"; do
            git subtree pull --message "SUBTREE-PULL $tree" --prefix="$tree" --squash # git.mt-software.de:"/git/openerp/modules/$1" master
        done

        ;;

    elif command == "push":
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR" || exit -1

        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Please provide the submodule name."
            exit -1
        fi

        cd "$CUSTOMS_DIR"
        module="${ALL_PARAMS[0]}"
        git subtree push --prefix="common/$module" git.mt-software.de:"/git/openerp/modules/$module" master

        ;;

    elif command == "rmpyc":
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR" || exit -1
        find . -name *.pyc -delete
        ;;


    elif command == "submodule":
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)

        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Please provide the submodule name."
            exit -1
        fi

        cd "$CUSTOMS_DIR"
        if [[ ! -d common ]]; then
            echo "Directory common not found - are you in root?"
            exit 1
        fi

        if [[ ! -d ".git" ]]; then
            git init .
        fi

        for i in ${ALL_PARAMS[0]//,/ };
        do
            git subtree add --prefix="common/$i" --squash git.mt-software.de:"/git/openerp/modules/$i" master
        done
        ;;

    elif command == "update-ast":
        if [[ "$PLATFORM" == "OSX" ]]; then
            echo "Update is extreme slow on osx due to share performance. Please use following command natively:"
            echo
            echo
            echo 'time PYTHONPATH=$ODOO_HOME/admin/module_tools python -c "from odoo_parser import update_cache; update_cache()"'
            echo
            echo
            exit 2
        fi
        cd admin/module_tools
        echo "Updating ast - can take about one minute; slow on OSX due to share"
        time python -c'from odoo_parser import update_cache; update_cache()'
        ;;

    elif command == "migrate":
        LOGFILE = os.path.join(odoo_config.customs_dir(), "migration.log")
        python migrate.py --log-file "$LOGFILE" --manage-command "$MANAGE" "${ALL_PARAMS[@]}"

    else:
        raise Exception("Unknown Command: {} {}".format(command, " ".join(command_parameters)))

def __do_restore_files(filepath):
    # remove the postgres volume and reinit
    dcrun(['odoo', '/bin/restore_files.sh', os.path.basename(filepath)])

if __name__ == '__main__':
    _startup()
    _check_working_dir_customs_mismatch
    if args:
        if args[0] == 'tool':
            from module_tools.tools import run
            run(*args)
            sys.exit(0)

    _export_settings()
    _remember_customs_and_cry_if_changed
    if args and args[0] in ['build', 'compose']:
        _remove_temp_directories()
        _prepare_filesystem()
        _prepare_yml_files_from_template_files()
        _reset_proxy_configs()
        _setup_proxy()
        _setup_odoo_instances()
    _sanity_check()

    try:
        command_parameters = args[1:] if len(args) > 1 else []
        do_command(args[0], command_parameters)
        pass
    finally:
        _cleanup
