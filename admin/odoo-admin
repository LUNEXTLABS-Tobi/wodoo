#!/bin/bash
#set -u # treat unset variables as error
# Basic Rules:
# - if a command would stop production run, then ask to continue is done before
# - if in set -e environment and piping commands like cat ... |psql .. then use: pipe=$(mktemp -u); mkfifo $pipe; do.. > $pipe &; do < $pipe
#
# Important Githubs:
#   * https://github.com/docker/compose/issues/2293  -> /usr/local/bin/docker-compose needed
#   * there is a bug: https://github.com/docker/compose/issues/3352  --> using -T
#
# TODO use shift instead of ARGS, ALL_PARAMS - is more bash style
# TODO replace all bash commands to be called within dockerbash

function dcrun() {
    $dc run -T -e ODOO_HOME=/opt/odoo "$@"
}

function dcexec() {
    $dc exec -T "$@"
}

function get_platform() {
    if [[ "$PLATFORM" == "Darwin" || "$PLATFORM" == "OSX" ]]; then
        echo "OSX"
    else
        echo "Linux"
    fi
}

function join_by { local IFS="$1"; shift; echo "$*"; }

function startup() {
    PLATFORM="$(get_platform)"
    unset -f get_platform
    local ARGS=("$@")
    local $DIR >/dev/null
    DIR=$(realpath "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/..")

    proxy_configs_dir=$DIR/run/proxy
    export proxy_configs_dir="$proxy_configs_dir"
    ALL_PARAMS=("${ARGS[@]:1}") # all parameters without command
    export ODOO_MANAGER_STARTED_ONCE=1
    export ODOO_COMPOSE_VERSION="3.3"
    export PGPASSFILE=/tmp/.pgpass # must match the executing script
    export PGHOST="$DB_HOST"
    export PGPORT="$DB_PORT"
    export PGUSER="$DB_USER"
    export LOCAL_WORKING_DIR="$EXTERNAL_ROOT/$WORKING_DIR"  # the working directory accessible from container of this script.
    docker_compose_file="$DIR/run/docker-compose.yml"
    return 0
}

function check_working_dir_customs_mismatch() {
    # Checks wether the current working is in a customs directory, but
    # is not matching the correct customs. Avoid creating wrong tickets
    # in the wrong customizations.

    res=$(python <<-EOF
import os
import time
working_dir = os.environ['LOCAL_WORKING_DIR']
while not os.path.isfile(os.path.join(working_dir, '.customsroot')):
    try:
        working_dir = os.path.dirname(working_dir)
    except:
        break
    if not working_dir.replace("/", ""):
        break
if os.path.isfile(os.path.join(working_dir, '.customsroot')):
    current_customs = os.path.basename(working_dir)
    if current_customs != os.environ['CUSTOMS']: 
        print "Caution: current customs is {} but you are in another customs directory: {}".format("$CUSTOMS", "$LOCAL_WORKING_DIR")
        print "Continue at your own risk!"
EOF
    )

    echo "$res" | grep -q 'risk' && {
        echo ''
        echo -e "\e[31m"
        echo "$res"
        echo -e "\e[39m"
        echo ''
        secs=10
        read -p "Continue in $secs seconds or press any key to continue now..." -N 1 -s -t $secs a || true
    }
    echo ''
    echo ''
}

function get_CUSTOMS_DIR() {
    local CUSTOMS_DIR

    CUSTOMS_DIR=$(
    cd "$DIR/admin/module_tools" && \
    python <<- EOF
import odoo_config
v = odoo_config.customs_dir()
print v
EOF
    )
    echo "$CUSTOMS_DIR"
}

function default_confs() {
    MANAGE="$DIR/admin/odoo-admin"
    local ARGS=("$@")
    export FORCE_CONTINUE=0
    FORCE=0
    echo "${ARGS[*]}" |grep -q '[-]force' && {
        FORCE=1
    }

    if [[ -z "$FORCE_UNVERBOSE" ]]; then
        FORCE_UNVERBOSE=0
    fi
    echo "${ARGS[*]}" |grep -q '[-]unverbose' && {
        FORCE_UNVERBOSE=1
    }
    return 0
}

function make_path_as_hosts_sees_it() {
    #
    #
    # converts /ROOT/home/marc... to /home/marc
    # converts /WORKING_DIR/dumpfile... to /tmp/a/b/c/dumpfile
    #
    local path
    path="$1"

    if [[ "$path" == $EXTERNAL_ROOT* ]]; then
        path=${path:${#EXTERNAL_ROOT}}
    fi

    if [[ "$path" == */WORKING_DIR/* ]]; then
        path=${path/\/WORKING_DIR/$WORKING_DIR}
    fi
    echo "$path"
}

function make_path_accessible_from_container_but_file_is_outside() {
    #
    # Transforms relative paths and absolute path to a path,
    # that resolves to the host.
    #
    # odoo calls this script with WORKING_DIR set, so we know
    # for relative paths, where to start.
    #
    # example:
    #
    # /opt/dumps/db1.gz --> /ROOT/dumps/db1.gz
    # dumps/db1.gz --> /home/user1/dumps/db1.gz where /home/user1 is $WORKING_DIR
    #
    local path
    path="/WORKING_DIR/$1"
    path=$(readlink -f "$path")
    realpath "$path"
}

function file2env() {
    if [[ ! -f "$1" ]]; then
        return 0
    fi

    # set variables from settings
    while read -r line; do
        # reads KEY1=A GmbH and makes export KEY1="A GmbH" basically
        [[ "$line" == '#*' ]] && continue
        [[ "$line" == '' ]] && continue
        var="${line%=*}"
        value="${line##*=}"
        eval "$var=\"$value\""
        export "$var" # export local variable to environment
    done <"$1"

    return 0
}

function export_settings() {
    SETTINGS_FILE="$DIR/run/settings"
    if [[ ! -e "$SETTINGS_FILE" ]]; then
        case $1 in
            build|compose)
                echo "CUSTOMS=$2" > "$SETTINGS_FILE"
            ;;
            *)
                echo "Please call ./odoo compose <CUSTOMS> initially."
                exit 1
        esac
    fi
    file2env "$SETTINGS_FILE"

    # get odoo version
    ODOO_VERSION=$(
    cd "$DIR/admin/module_tools" || exit -1
    python <<-EOF
import odoo_config
v = odoo_config.get_version_from_customs("$CUSTOMS")
print v
EOF
    )
    export ODOO_VERSION=$ODOO_VERSION
    case "$ODOO_VERSION" in
        "6.0"|"6.1"|"7.0"|"8.0"|"9.0")
            export ODOO_PYTHON_VERSION=2
            export ODOO_EXECUTABLE=openerp-server
            ;;
        "10.0")
            export ODOO_PYTHON_VERSION=2
            export ODOO_EXECUTABLE=odoo-bin
            ;;
        *)
            export ODOO_PYTHON_VERSION=3
            export ODOO_EXECUTABLE=odoo-bin
        ;;
    esac


    # set odoo version in settings file for machines
    cd "$DIR/admin/module_tools" || exit -1
    python <<- END
import os
import odoo_config
os.environ['ODOO_HOME'] = os.getenv("LOCAL_ODOO_HOME")
env = odoo_config.get_env()
env['ODOO_VERSION'] = "$ODOO_VERSION"
env.write()
END

    if [[ "$FORCE_UNVERBOSE" == "1" ]]; then
        VERBOSE=0
    fi

    [[ "$VERBOSE" == "1" ]] && set -x

    dc="/usr/local/bin/docker-compose -p $DCPREFIX -f $docker_compose_file"
    return 0
}

function restore_check() {
    dumpname="$(basename "$1")"
    local force=0

    # asterisk as one word, @ as separate words
    echo "${ALL_PARAMS[*]}" |grep -P -q '[-]force' && {
        force=1
    }

    if [[ ! "${dumpname%.*}" == *"$DBNAME"* ]]; then
        echo "The dump-name \"$dumpname\" should somehow match the current database \"$DBNAME\", which isn't."
        exit -1
    fi

    return 0
}

function exists_db() {
    sql=("select 'database_exists' from pg_database where datname='$DBNAME'")
    if FORCE_UNVERBOSE=1 echo "${sql[0]}"| $MANAGE psql template1 | grep -q 'database_exists'
    then
        echo 'database exists'
    else
        echo 'database does not exist'
    fi

    return 0
}

function remove_postgres_connections() {
    echo "Removing all current connections"

    if [[ "$(exists_db)" != "database does not exist" ]]; then
        SQL=$(cat <<-EOF
            SELECT pg_terminate_backend(pg_stat_activity.pid)
            FROM pg_stat_activity 
            WHERE pg_stat_activity.datname = '$DBNAME' 
            AND pid <> pg_backend_pid(); 
EOF
            )
        echo "$SQL" | $MANAGE psql template1
    fi

    return 0
}

function do_restore_db_in_docker_container () {
    # remove the postgres volume and reinit

    echo "Restoring dump within docker container postgres"
    dump_file="$1"

    if [[ ! -f "$dump_file" ]]; then
        echo "File $dump_file not found!"
        exit -1
    fi

	$MANAGE kill
	$dc rm -f || true
	if [[ "$RUN_POSTGRES" == 1 ]]; then
		askcontinue "Removing docker volume postgres-data (irreversible)"
	fi
	VOLUMENAME=${DCPREFIX}_postgresdata
	docker volume ls |grep -q "$VOLUMENAME" && docker volume rm "$VOLUMENAME"
	$MANAGE reset-db
	RESTOREFILE=/opt/dumpfile
	dump_file=$(make_path_as_hosts_sees_it "$dump_file")
	dcrun -v "$dump_file:$RESTOREFILE" -e "RESTOREFILE=$RESTOREFILE" postgres /restore.sh
}

function do_restore_db_on_external_postgres () {
    SUFFIX="_restoring"
    DBNAME_TARGET="$DBNAME"
    DBNAME="${DBNAME}${SUFFIX}"
    export DBNAME="$DBNAME"

    echo "Restoring dump on $DB_HOST"
    dump_file=$1
    echo "Using Host: $DB_HOST, Port: $DB_PORT, User: $DB_USER, ...."
    export PGPASSWORD=$DB_PWD
    local args="-h $DB_HOST -p $DB_PORT -U $DB_USER"
    DROPDB="dropdb $args"
    CREATEDB="createdb $args"
    PGRESTORE="pg_restore $args"

    eval "$DROPDB --if-exists $DBNAME" || echo "Failed to drop $DBNAME"
    eval "$CREATEDB $DBNAME"
    pipe="$(mktemp -u)"
    mkfifo "$pipe"
    gunzip -c "$1" > "$pipe" &
    echo "Restoring Database $DBNAME"
    $PGRESTORE -d "$DBNAME" < "$pipe"

    remove_postgres_connections
    sql=("
        SELECT pg_terminate_backend(pg_stat_activity.pid)
        FROM pg_stat_activity 
        WHERE pg_stat_activity.datname = '$DBNAME_TARGET' 
        AND pid <> pg_backend_pid(); 

        drop database if exists $DBNAME_TARGET;
        alter database $DBNAME rename to $DBNAME_TARGET;
        ")
    echo "${sql[0]}"| $MANAGE psql template1

    DBNAME="$DBNAME_TARGET"
    export DBNAME="$DBNAME"
    remove_postgres_connections

    return 0
}

function do_restore_files () {
    # remove the postgres volume and reinit
    filepath=$1

    filepath=$(make_path_as_hosts_sees_it "$filepath")
    RESTOREFILE=/tmp/archive
    dcrun -v "$filepath:$RESTOREFILE" odoo /bin/restore_files.sh
    return 0
}

function askcontinue() {
    if [[ "$1" != "-force" ]]; then
        echo "$1"
    fi
    force=0
    echo "$*" |grep -q '[-]force' && {
        force=1
    }
    if [[ "$force" == "1" || "$FORCE" == "1" || "$FORCE_CONTINUE" == "1" ]]; then
        # display prompt
        echo "Ask continue disabled, continuing..."
    else
        read -r -p "Continue? (Ctrl+C to break)" || {
            exit -1
        }
    fi
    return 0
}

function showhelp() {
    echo Management of odoo instance
    echo
    echo
    echo ./odoo sanity-check
    echo Reinit fresh db:
    echo './odoo reset-db'
    echo
    echo Update:
    echo './odoo update [module]'
    echo 'Just custom modules are updated, never the base modules (e.g. prohibits adding old stock-locations)'
    echo 'Minimal downtime - but there is a downtime, even for phones'
    echo 
    echo "Please call odoo springclean|update|backup|run_standalone|upall|attach_running|rebuild|restart"
    echo ""
    echo "abort-upgrade"
    echo ""
    echo "attach <machine> - attaches to running machine"
    echo ""
    echo "backup <backup-dir> - backup database and/or files to the given location with timestamp; if not directory given, backup to dumps is done "
    echo ""
    echo "backup-db <backup-dir>"
    echo ""
    echo "backup-files <backup-dir>"
    echo ""
    echo "debug <machine-name> - starts /bin/bash for just that machine and connects to it; if machine is down, it is powered up; if it is up, it is restarted; as command an endless bash loop is set"
    echo ""
    echo "dev - starts developing in the odoo container"
    echo ""
    echo "build - no parameter all machines, first parameter machine name and passes other params; e.g. ./odoo build asterisk --no-cache"
    echo ""
    echo "link - links all modules into ./links"
    echo ""
    echo "telegram-setup- helps creating a permanent chatid"
    echo ""
    echo "kill - kills running machines"
    echo ""
    echo "logs - show log output; use parameter to specify machine"
    echo ""
    echo "logall - shows log til now; use parameter to specify machine"
    echo ""
    echo "springclean - remove dead containers, untagged images, delete unwanted volums"
    echo ""
    echo "rm - command"
    echo ""
    echo "compose - just build the big docker-compose file"
    echo ""
    echo "rebuild - rebuilds docker-machines - data not deleted"
    echo ""
    echo "restart - restarts docker-machine(s) - parameter name"
    echo ""
    echo "restore <filepathdb> <filepath_tarfiles> [-force] - restores the given dump as odoo database"
    echo ""
    echo "restore-dev-db - Restores database dump regularly and then applies scripts to modify it, so it can be used for development (adapting mailserver, disable cronjobs)"
    echo ""
    echo "runbash <machine name> - starts bash in NOT RUNNING container (a separate one)"
    echo ""
    echo "setup-startup makes skript in /etc/init/${CUSTOMS}"
    echo ""
    echo "stop - like docker-compose stop"
    echo ""
    echo "quickpull - fetch latest source, oeln - good for mako templates"
    echo ""
    echo "turn-into-dev - applies scripts to make the database a dev database"
    echo ""
    echo "update <machine name>- fetch latest source code of modules and run update of just custom modules; machines are restarted after that"
    echo ""
    echo "up - starts all machines equivalent to service <service> start "
    echo ""
    echo "remove-web-assets - if odoo-web interface is broken (css, js) then purging the web-assets helps; they are recreated on odoo restart"
    echo ""
    echo "fix-permissions - sets user 1000 for odoo and odoo_files"
    echo ""
    echo "show-install-state "
    echo ""
    echo "make-customs"
    echo
    echo "patch - run without arguments for help"
    echo ""
    echo "version - run without arguments for help"
    echo ""
}

if [ -z "$1" ]; then
    showhelp
    exit -1
fi

function prepare_filesystem() {
    mkdir -p "$DIR"/run/{config,sqlscripts,debug,proxy}
    sudo -E chown $UID:$UID -R "$DIR"/run

    if [[ ! -e "$DIR/run/odoo_instances" ]]; then
        echo "default default" > "$DIR/run/odoo_instances"
    fi

    return 0
}

function prepare_yml_files_from_template_files() {
    # replace params in configuration file
    # replace variables in docker-compose;
    cd "$DIR"

    if [[ "$ODOO_MANAGER_STARTED_ONCE" != "1" ]]; then
        echo "CUSTOMS: $CUSTOMS"
        echo "DB: $DBNAME"
        echo "VERSION: $ODOO_VERSION"
        echo "FILES: $ODOO_FILES"
    fi
    CUSTOMS_DIR=$(get_CUSTOMS_DIR)

    # python: find all configuration files from machines folder; extract sort 
    # by manage-sort flag and put file into run directory
    # only if RUN_parentpath like RUN_ODOO is <> 0 include the machine
    #
    # - also replace all environment variables
    PATTERN='docker-compose*.yml'
    rm "$DIR/run/$PATTERN" > /dev/null 2>&1 || true

    declare -a all_dirs
    all_dirs[0]="machines"
    if [[ -d "$CUSTOMS_DIR/machines" ]]; then
        all_dirs[1]="$CUSTOMS_DIR/machines"
    fi
    ALL_SETTINGS=$(cd "$DIR"; find "${all_dirs[@]}" -name default.settings)
    ALL_SETTINGS=$(echo "$ALL_SETTINGS" | while read -r f; do readlink -e "$f"; done) # make absolute path
    ALL_SETTINGS=$(echo -e "machines/defaults\n$ALL_SETTINGS")
    # append config from customs
    if [[ "$CUSTOMS" != "" && -e "$DIR/data/src/customs/$CUSTOMS/settings" ]]; then
        ALL_SETTINGS=$(echo -e "$DIR/data/src/customs/$CUSTOMS/settings")
    fi
    # append config file from etc as last
    if [[ "$CUSTOMS" != "" && -e "/etc_host/odoo/settings" ]]; then
        ALL_SETTINGS=$(echo -e "/etc_host/odoo/settings")
    fi
    if [[ "$CUSTOMS" != "" && -e "/etc_host/odoo/$CUSTOMS/settings" ]]; then
        ALL_SETTINGS=$(echo -e "/etc_host/odoo/$CUSTOMS/settings")
    fi

    python ./admin/make_settings.py "$SETTINGS_FILE" "$ALL_SETTINGS"
    file2env "$SETTINGS_FILE"

    ALL_CONFIG_FILES=$(cd "$DIR"; find "${all_dirs[@]}" -name "$PATTERN")

    # Make all config files to absolutepath
    ALL_CONFIG_FILES=$(echo "$ALL_CONFIG_FILES" | while read -r f; do readlink -e "$f"; done)

    python ./admin/prepare_dockercompose_files.py ./run/docker-compose.yml "$ALL_CONFIG_FILES"

    return 0
}


function do_command() {
    case $1 in
    abort-upgrade)
        SQL=$(cat <<-EOF
            UPDATE ir_module_module SET state = 'installed' WHERE state = 'to upgrade';
            UPDATE ir_module_module SET state = 'uninstalled' WHERE state = 'to install';
EOF
            )
        echo "$SQL" | $MANAGE psql "$DBNAME"

        ;;
    setup-startup)
        PATH=$DIR
        exit 5

        if [[ -f /sbin/initctl ]]; then
            # ubuntu 14.04 upstart
            file=/etc/init/${CUSTOMS}_odoo.conf

            echo "Setting up upstart script in $file"
            /bin/cp "$DIR/config/upstart" "$file"
            /bin/sed -i -e "s/\${DCPREFIX}/$DCPREFIX/" -e "s/\${DCPREFIX}/$DCPREFIX/" "$file"
            /bin/sed -i -e "s|\${PATH}|$PATH|" -e "s|\${PATH}|$PATH|" "$file"
            /bin/sed -i -e "s|\${CUSTOMS}|$CUSTOMS|" -e "s|\${CUSTOMS}|$CUSTOMS|" "$file"
            /sbin/initctl reload-configuration
        else
            echo "Setting up systemd script for startup"
            servicename=${CUSTOMS}_odoo.service
            file=/lib/systemd/system/$servicename

            echo "Setting up upstart script in $file"
            /bin/cp "$DIR/config/systemd" "$file"
            /bin/sed -i -e "s/\${DCPREFIX}/$DCPREFIX/" -e "s/\${DCPREFIX}/$DCPREFIX/" "$file"
            /bin/sed -i -e "s|\${PATH}|$PATH|" -e "s|\${PATH}|$PATH|" "$file"
            /bin/sed -i -e "s|\${CUSTOMS}|$CUSTOMS|" -e "s|\${CUSTOMS}|$CUSTOMS|" "$file"

            /bin/systemctl disable "$servicename"
            /bin/rm "/etc/systemd/system/$servicename"
            /bin/rm "lib/systemd/system/$servicename"
            /bin/systemctl daemon-reload
            /bin/systemctl reset-failed
            /bin/systemctl enable "$servicename"
            /bin/systemctl start "$servicename"
        fi
        ;;
    exec)
        $dc exec "${ALL_PARAMS[@]}"
        ;;
    backup-db)
        if [[ -n "$2" ]]; then
            BACKUPDIR=$2
			
        else
            BACKUPDIR=$DIR/dumps
        fi
        filename=$DBNAME.$(date "+%Y-%m-%d_%H%M%S").dump.gz
        filepath=$BACKUPDIR/$filename
        LINKPATH=$DIR/dumps/latest_dump
		if [[ "$RUN_POSTGRES" == "1" ]]; then
			$dc up -d postgres odoo
			dcexec postgres /backup.sh
			mv "$DIR/dumps/$DBNAME.gz" "$filepath"
		else
			set -e
			pg_dump -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -Z0 -Fc "$DBNAME" | pigz --rsyncable > "$filepath"
			set +e
		fi
		if [[ "$NO_BACKUP_SYMBOLIC_LINK_DUMP" != "1" ]]; then
			/bin/rm "$LINKPATH"
			ln -s "$filepath" "$LINKPATH" > /dev/null 2>&1
		fi
        md5sum "$filepath"
        echo "Dumped to $filepath"
		$MANAGE telegram-send "Database Backup $DBNAME done to $filepath"
        ;;
    backup-files)
        if [[ -n "$2" ]]; then
            BACKUPDIR=$2
        else
            BACKUPDIR=$DIR/dumps
        fi
        BACKUP_FILENAME=$CUSTOMS.files.tar.gz
        BACKUP_FILEPATH=$BACKUPDIR/$BACKUP_FILENAME

		dcrun odoo /backup_files.sh
        [[ -f $BACKUP_FILEPATH ]] && rm -Rf "$BACKUP_FILEPATH"
        mv "$DIR/dumps/odoofiles.tar" "$BACKUP_FILEPATH"

        echo "Backup files done to $BACKUP_FILEPATH"
        ;;

    backup)
		$MANAGE backup-db "${ALL_PARAMS[@]}"
		$MANAGE backup-files "${ALL_PARAMS[@]}"
        ;;
    reset-db)
		echo "$*" |grep -q '[-]force' || {
            askcontinue "Deletes database $DBNAME!"
		}
		if [[ "$RUN_POSTGRES" != "1" ]]; then
			echo "Postgres container is disabled; cannot reset external database"
			exit -1
		fi
        echo "Stopping all services and creating new database"
        echo "After creation the database container is stopped. You have to start the system up then."
        $dc kill
        dcrun -e INIT=1 postgres /entrypoint2.sh
        echo
        echo 
        echo
        echo "Database initialized. You have to restart now."

        ;;

	restore-files)
		set -e
		dumpfile=$(make_path_accessible_from_container_but_file_is_outside "$2")
        if [[ -z "$2" ]]; then
			echo "Please provide the tar file-name."
			exit -1
        fi
		echo 'Extracting files...'
		do_restore_files "$dumpfile"
		;;

	restore-db)
		set -e
		echo "DB_HOST: $DB_HOST"
		echo "DB_PORT: $DB_PORT"
		dumpfile=$(make_path_accessible_from_container_but_file_is_outside "$2")
		restore_check "$dumpfile"

		if [[ "$DEVMODE" == "1" && "$RESTORE_DEV_DB" != "1" ]]; then
			askcontinue "DEVMODE ist set - really restore as normal db? Not using restore-dev-db?"
		fi

		echo "$*" |grep -q '[-]force' || {
			askcontinue "Deletes database $DBNAME!"
		}

		if [[ "$RUN_POSTGRES" == "1" ]]; then
			do_restore_db_in_docker_container "$dumpfile"
		else
			askcontinue "Trying to restore database on remote database. Please make sure, that the user $DB_USER has enough privileges for that."
			do_restore_db_on_external_postgres "$dumpfile"
		fi

		remove_postgres_connections
		set_db_ownership
		$MANAGE telegram-send "Database Restore $DBNAME done."

		;;
	set_db_ownership)
		set_db_ownership
		;;

	proxy-reload)
		dcexec proxy /opt/bin/hot_reload.sh
		;;

    restore-dev-db)
		if [[ "$ALLOW_RESTORE_DEV" ]]; then
			echo "ALLOW_RESTORE_DEV must be explicitly allowed."
			exit -1
		fi
        echo "Restores dump to $DB_HOST and executes to scripts to adapt user passwords, mailservers and cronjobs"
		export RESTORE_DEV_DB=1
		set +e
		$MANAGE restore-db "${ALL_PARAMS[@]}" || true # ignore restore errors like not found user and so
		$MANAGE turn-into-dev "${ALL_PARAMS[@]}"

        ;;
	turn-into-dev)
		if [[ "$DEVMODE" != "1" ]]; then
			echo "When applying this sql scripts, the database is not usable anymore for production environments. "
			echo "Please set DEVMODE=1 to allow this"
			exit -1
		fi
        SQLFILE=machines/postgres/turndb2dev.sql
		$MANAGE psql "$DBNAME" < $SQLFILE
		
		;;
	psql)
		# gets sql query from pipe
		# check if there is a pipe argument
		local query=""
		if [[ ! -t 0 ]]; then  # checks if there is pipe data https://unix.stackexchange.com/questions/33049/check-if-pipe-is-empty-and-run-a-command-on-the-data-if-it-isnt
			query="$(cat /dev/stdin)"
		fi	

		if [[ "$RUN_POSTGRES" == "1" ]]; then
			$dc up -d postgres
			$MANAGE wait_for_container_postgres
            SQLFILE="$DIR/run/sqlscripts/script.sql"
            echo "$query" | tee "$SQLFILE"

            dcexec postgres gosu postgres psql "${ALL_PARAMS[*]}" -U "$DB_USER" -f "/opt/sqlscripts/$(basename "$SQLFILE")"
            rm "$SQLFILE"
		else
			export PGPASSWORD=$DB_PWD
			echo "$query" | psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -w "${ALL_PARAMS[@]}"
		fi 
		;;

    springclean)
        docker system prune

        echo removing dead containers
		docker ps -a -q | while read -r id; do
			docker rm "$id"
		done

        echo Remove untagged images
        docker images | grep "<none>" | awk '{ print "docker rmi " $3 }' | bash

        echo "delete unwanted volumes (can pass -dry-run)"
		docker images -q -f='dangling=true' | while read -r id; do
			docker rmi "$id"
		done
        ;;
    up)
		set_db_ownership
        $dc up "${ALL_PARAMS[@]}"
		$MANAGE proxy-reload
        ;;
    debug)
		# puts endless loop into container command and then attaches to it;
		# by this, name resolution to the container still works
        if [[ -z "$2" ]]; then
            echo "Please give machine name as second parameter e.g. postgres, odoo"
            exit -1
        fi
		set_db_ownership
        echo "Current machine $2 is dropped and restartet with service ports in bash. Usually you have to type /debug.sh then."
        askcontinue
        # shutdown current machine and start via run and port-mappings the replacement machine
		$MANAGE kill "$2"
        cd "$DIR"
		DEBUGGING_COMPOSER=$DIR/run/debugging.yml
		cp "$DIR/config/debugging/template.yml" "$DEBUGGING_COMPOSER"
		sed -i -e "s/\${DCPREFIX}/$DCPREFIX/" -e "s/\${NAME}/$2/" "$DEBUGGING_COMPOSER"
		dc="$dc -f $DEBUGGING_COMPOSER"  # command now has while loop

        #execute self
		$dc up -d "$2"
		$MANAGE attach "$2"

        ;;
    attach)
        if [[ -z "$2" ]]; then
            echo "Please give machine name as second parameter e.g. postgres, odoo"
            exit -1
        fi
		display_machine_tips "$2"
        $dc exec "$2" bash
        ;;
    run)
		set_db_ownership
        $dc run "${ALL_PARAMS[@]}"
		;;
    runbash)
        if [[ -z "$2" ]]; then
            echo "Please give machine name as second parameter e.g. postgres, odoo"
            exit -1
        fi
		set_db_ownership
		display_machine_tips "$2"
        $dc run --rm "$2" bash
        ;;
    rebuild)
        cd "$DIR"
        $dc build --no-cache "${ALL_PARAMS[@]}"
        ;;
    build)
        cd "$DIR"
        $dc build "${ALL_PARAMS[@]}"
        ;;
	force-kill)
		if [[ -z "$2" ]]; then
			echo "Please provide machine name."
			exit 1
		fi
        eval "$dc kill $2"
		;;
    kill)
        cd "$DIR"
		if [[ -z "$2" ]]; then
			eval "$dc stop -t 20 redis"  # persist data
			if [[ "$RUN_POSTGRES" == "1" ]]; then
				eval "$dc stop -t 20 postgres"
			fi
		fi
		eval "$dc stop -t 10 $2 $3 $4 $5 $6 $7 $8 $9"
        ;;
    stop)
        cd "$DIR"
        eval "$dc stop $2 $3 $4"
        ;;
    logsn)
        cd "$DIR"
        eval "$dc logs --tail=$2 -f -t $3 $4"
        ;;
    logs)
        cd "$DIR"
        lines="${ARGS[-1]}"
        if [[ -n ${lines//[0-9]/} ]]; then
            lines="5000"
        else
            echo "Showing last $lines lines"
        fi
        eval "$dc logs --tail=$lines -f -t $2 "
        ;;
    logall)
        cd "$DIR"
        eval "$dc logs -f -t $2 $3"
        ;;
    rm)
        cd "$DIR"
        $dc rm "${ALL_PARAMS[@]}"
        ;;
    restart)
        cd "$DIR"
        eval "$dc stop $2"
        eval "$dc rm -f $2"
        eval "$dc up --force-recreate -d $2"
        $MANAGE proxy-reload
        ;;

    dev)
        if [[ -n "${ALL_PARAMS[0]}" ]]; then
            $MANAGE customs "${ALL_PARAMS[@]}"
        fi
        $MANAGE kill
        $MANAGE rm -f
        $MANAGE build
        $MANAGE up -d
        $MANAGE attach odoo
        ;;

    telegram-setup)
        if [[ "$TELEGRAM_ENABLED" == "1" ]]; then
            export DIR="$DIR"
            cd "$DIR"/config/telegrambot
            docker-compose run telegrambot /setup.sh
        fi
        ;;
    telegram-send)
        if [[ "$TELEGRAM_ENABLED" == "1" ]]; then
            export DIR="$DIR"
            cd "$DIR"/config/telegrambot
            docker-compose run telegrambot /send.py "$2"
        fi
        ;;
    fix-permissions)
        if [[ -d "$ODOO_FILES" && -n "$ODOO_FILES" ]]; then
            chown "1000" -R "$ODOO_FILES"
        fi
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        if [[ -d "$CUSTOMS_DIR" && -n "$CUSTOMS_DIR" ]]; then
            chown "$USER" -R "$CUSTOMS_DIR"
        fi

        ;;
    update)

        $MANAGE abort-upgrade

        echo "Run module update"
        if [[ -n "$ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER" ]]; then
            date +%s > "$ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER"
        fi
        # running duplicate updates is really a problem;
        $dc kill 
        $dc rm -f
        $dc create --force-recreate
        if [[ "$RUN_POSTGRES" == "1" ]]; then
            $dc up -d postgres
            $MANAGE wait_for_container_postgres
        fi

        dcrun odoo_update /update_modules.sh "$2" || {
            res="$?"
            echo "Error at /update_modules.sh - aborting update process."
            exit $res
        }
        $MANAGE show-install-state || exit 34

        for i in $(seq 5);
        do
            $dc up -d
            $MANAGE proxy-reload
            sleep 2
        done

        df -h / # case: after update disk / was full
        if [[ -n "$ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER" ]]; then
            echo '0' > "$ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER"
        fi
        $MANAGE telegram-send "Update done" # &> /dev/null

       ;;

    show-install-state)
        SQL=$(cat <<-EOF
            SELECT name, state from ir_module_module where state not in ('installed', 'uninstalled');
EOF
            )
        echo "Displaying dangling modules:"
        echo "$SQL" | $MANAGE psql "$DBNAME"

        has_dangling=$(echo "$SQL" | $MANAGE psql "$DBNAME" | grep "(0 rows)")
        if [[ -z "$has_dangling" ]]; then
            echo "Dangling modules detected - please fix installation problems and retry!"
            exit -32
        fi
        ;;

    get_all_langs)
        SQL="select code from res_lang;"
        langs=$(echo "$SQL" | $MANAGE psql --tuples-only "$DBNAME")
        echo $langs
        ;;

    export-i18n|export_i18n)
        LANG=$2
        MODULES=$3
        if [[ -z "$MODULES" ]]; then
            echo "Syntax: export-i18n LANG MODULES"
            exit -1
        fi
        dcrun odoo /export_i18n.sh "$LANG" "$MODULES"
        # file now is in $DIR/run/i18n/export.po
        ;;

    import-i18n)
        dcrun odoo /import_i18n.sh "${ALL_PARAMS[@]}"
        ;;

    remove-web-assets)
        askcontinue
        dcrun odoo bash -c "cd ./admin/module_tools; python -c'from module_tools import remove_webassets; remove_webassets()'"
        echo
        echo
        echo "Please login as admin, so that assets are recreated."
        echo
        echo
        echo
        ;;
    sanity_check)
        sanity_check
        ;;
    make_customs)
        set -e
        askcontinue
        $MANAGE kill
        CUSTOMS=$2
        VERSION=$3
        "$DIR/admin/module_tools/make_customs" "$2" "$3"
        cd "$DIR/admin/module_tools"
        python <<- END
import odoo_config
odoo_config.set_customs("$2")
END

        cd "$DIR/customs/$2"
        git submodule add https://github.com/odoo/odoo odoo
        cd odoo
        git checkout "$VERSION"
        "$DIR/admin/OCA-all"
        "$DIR/admin/odoo-submodule tools,web_modulesroduct_modules,calendar_ics"
        "$DIR/$MANAGE" up -d
        chromium-browser http://localhost

        ;;
    OCA)
        "$DIR/admin/OCA" "${ALL_PARAMS[@]}"
        ;;
    compose)
        echo "Built the docker-compose file."
        ;;
    simplebash)
        if [[ "${#ALL_PARAMS[@]}" == "0" ]]; then
            bash --noprofile
        else
            bash --noprofile -c "${ALL_PARAMS[*]}"
        fi
        ;;
    test)
        echo 'reached the command area'
        echo "DIR is: $DIR"
        echo "CUSTOMS is: $CUSTOMS"
        sudo echo "This was sudoed"
        echo "Here is pgpassfile: $PGPASSFILE"
        echo "Now calling simple psql"
        SQL=$(cat <<-'            EOF'
            select state, count(*) from ir_module_module group by state;
            EOF
            )
        echo "$SQL" | $MANAGE psql "$DBNAME"
        ;;
    test_make_error)
        echo "now throwing exit code"
        exit -123
        ;;
    progress)
        SQL=$(cat <<-EOF
            select state, count(*) from ir_module_module group by state;
EOF
            )
        echo "$SQL" | $MANAGE psql "$DBNAME"

        ;;
    prepare)
        echo "All configurations prepared."
        ;;
    link)
        python "$DIR/admin/link_modules"
        ;;

    patch)
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR/odoo" || exit 1
        cmd=("$DIR/admin/odoo-patch")
        cmd+=("${ALL_PARAMS[@]}")
        eval "${cmd[@]@Q}"
        ;;
    wait_for_port)
        started=$(date +"%s")
        while ! nc -q 1 "$2" "$3" </dev/null; do 
            sleep 1;
            now=$(date +"%s")
            (( elapsed = ("$now" - "$started") % 5))
            if [[ "$elapsed" == "0" ]]; then
                echo "Waiting for $2 on port $3..."
            fi

            if [[ "$elapsed" -gt 20 ]]; then
                echo "Waiting too long for $2 on port $3. Exiting with error-code."
                exit 20
            fi
        done
        ;;
    wait_for_container_postgres)
        $MANAGE wait_for_port postgres 5432
        ;;

    dirty)
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=("dirty")
        eval "${cmd[@]@Q}"
        ;;
    stage)
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=("stage-ticket")
        cmd+=( "${ALL_PARAMS[@]}" )
        eval "${cmd[@]@Q}"
        ;;
    deploy)
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=("deploy-ticket")
        cmd+=( "${ALL_PARAMS[@]}" )
        eval "${cmd[@]@Q}"
        ;;
    versioning)
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=( "${ALL_PARAMS[@]}" )
        eval "${cmd[@]@Q}"
        ;;
    new-ticket|switch-ticket|mergeto|deploy-ticket|stage-ticket|commit|incversions|current-ticket|open-tickets)
        cmd=("$DIR/admin/module_tools/odoo-versioning")
        cmd+=("$1")
        cmd+=( "${ALL_PARAMS[@]}" )
        eval "${cmd[@]@Q}"
        ;;

    customs)
        # switch customs
        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Customs missing"
            exit 1
        fi
        newcustoms="${ALL_PARAMS[0]}"
        newdb="${ALL_PARAMS[1]}"

        if [[ -z "$newdb" ]]; then
            newdb=$newcustoms
        fi

        $(
        cd "$DIR/admin/module_tools"
        python <<-EOF
import odoo_config
odoo_config.set_customs("$newcustoms", "$newdb")
EOF
        )

        echo "Customs set to $newcustoms with database $newdb"

        ;;

    pull)
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR" || exit -1

        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Please provide the submodule name."
            exit -1
        fi
        if [[ ! -d ".git" ]]; then
            echo "No local git repo - where are you?"
            exit -1
        fi

        module="${ALL_PARAMS[0]}"
        git subtree pull --message "SUBTREE-PULL $module" --prefix="common/$module" --squash git.mt-software.de:"/git/openerp/modules/$module" master
        ;;

    pull-all)
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR" || exit -1

        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Please provide the submodule name."
            exit -1
        fi
        if [[ ! -d ".git" ]]; then
            echo "No local git repo - where are you?"
            exit -1
        fi

        all_trees=$(git log | grep git-subtree-dir | awk '{ print $2 }') # | awk '{ split($0,a,"/"); print a[2]}')
        readarray -t all_tres <<<"$all_trees"

        for tree in "${all_tres[@]}"; do
            git subtree pull --message "SUBTREE-PULL $tree" --prefix="$tree" --squash # git.mt-software.de:"/git/openerp/modules/$1" master
        done

        ;;

    push)
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR" || exit -1

        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Please provide the submodule name."
            exit -1
        fi

        cd "$CUSTOMS_DIR"
        module="${ALL_PARAMS[0]}"
        git subtree push --prefix="common/$module" git.mt-software.de:"/git/openerp/modules/$module" master

        ;;

    rmpyc)
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)
        cd "$CUSTOMS_DIR" || exit -1
        find . -name *.pyc -delete
        ;;


    submodule)
        CUSTOMS_DIR=$(get_CUSTOMS_DIR)

        if [[ -z "${ALL_PARAMS[0]}" ]]; then
            echo "Please provide the submodule name."
            exit -1
        fi

        cd "$CUSTOMS_DIR"
        if [[ ! -d common ]]; then
            echo "Directory common not found - are you in root?"
            exit 1
        fi

        if [[ ! -d ".git" ]]; then
            git init .
        fi

        for i in ${ALL_PARAMS[0]//,/ };
        do
            git subtree add --prefix="common/$i" --squash git.mt-software.de:"/git/openerp/modules/$i" master
        done
        ;;

    update-ast)
        if [[ "$PLATFORM" == "OSX" ]]; then
            echo "Update is extreme slow on osx due to share performance. Please use following command natively:"
            echo
            echo
            echo 'time PYTHONPATH=$ODOO_HOME/admin/module_tools python -c "from odoo_parser import update_cache; update_cache()"'
            echo
            echo
            exit 2
        fi
        cd admin/module_tools
        echo "Updating ast - can take about one minute; slow on OSX due to share"
        time python -c'from odoo_parser import update_cache; update_cache()'
        ;;

    *)
        echo "Invalid option $1"
        exit -1
        ;;
    esac
}


function cleanup() {

    if [[ -f config/docker-compose.yml ]]; then
        /bin/rm config/docker-compose.yml || true
    fi

    remove_temp_directories

}

function try_to_set_owner() {
    OWNER=$1
    dir=$2
    if [[ -d "$dir" && "$(stat -c "%u" "$dir")" != "$OWNER" ]]; then
        echo "Trying to set correct permissions on $dir"
        chown "$OWNER" "$dir"
        if [[ "$?" != 0 ]]; then
            sudo chown "$OWNER" "$dir"
        fi
    fi
}

function sanity_check() {

    if [[ ( "$RUN_POSTGRES" == "1" || -z "$RUN_POSTGRES" ) && "$DB_HOST" != 'postgres' ]]; then
        echo "You are using the docker postgres container, but you do not have the DB_HOST set to use it."
        echo "Either configure DB_HOST to point to the docker container or turn it off by: "
        echo 
        echo "RUN_POSTGRES=0"
        exit -1
    fi

    if [[ "$RUN_POSTGRES" == "1"  ]]; then
        RESTORE_DIR="$DIR/run/restore"
        if [[ -d "$RESTORE_DIR" ]]; then
            try_to_set_owner "1000" "$RESTORE_DIR"
        fi
    fi

    if [[ -d $ODOO_FILES ]]; then
        # checking directory permissions of session files and filestorage
        try_to_set_owner "1000" "$ODOO_FILES"
    fi

    # make sure the odoo_debug.txt exists; otherwise directory is created
    if [[ ! -f "$DIR/run/odoo_debug.txt" ]]; then
        touch "$DIR/run/odoo_debug.txt"
    fi

    if [[ -z "$ODOO_MODULE_UPDATE_RUN_TESTS" ]]; then
        echo "Please define wether to run tests on module updates by setting ODOO_MODULE_UPDATE_RUN_TESTS"
        echo
        exit -1
    fi

}

function set_db_ownership() {
    # in development environments it is safe to set ownership, so
    # that accidently accessing the db fails
    if [[ "$DEVMODE" == "1" ]]; then
        if [[ "$RUN_POSTGRES" == "1" ]]; then
            $dc up -d postgres
            $MANAGE wait_for_container_postgres
        fi
        dcrun odoo bash -c "cd ./admin/module_tools; python -c'from module_tools import set_ownership_exclusive; set_ownership_exclusive()'"
    fi
}

function display_machine_tips() {
    cd "$DIR"
    tipfile=$(find "machines" -name 'tips.txt' | grep -P "\/$1\/" | while read -r file; do
        echo "$DIR/$file"
    done)
    if [[ -f "$tipfile" ]]; then
        echo 
        echo Please note:
        echo ---------------
        echo
        cat "$tipfile"
        echo 
        echo
    fi

    return 0
}

function awk() {
    AWK=$(which awk)
    command "${AWK:-awk}" "$@";
    return 0
}

function reset_proxy_configs() {
    local configs_dir

    configs_dir="$DIR/run/proxy"

    cd "${configs_dir:?}" && rm -Rf *
}

function setup_odoo_instances() {
    local name
    local subdomain_path
    local config_path

    if [[ -f "$DIR/run/odoo_instances" ]]; then
        rm "${proxy_configs_dir:?}/*.host" 1>/dev/null 2>&1 || true

        while read -r line; do
            name="$(echo "$line"| awk '{print $1}')"
            domain="$(echo "$line"| awk '{print $2}')"

            config_path="$proxy_configs_dir/${name}.host"
            cp "$DIR/machines/proxy/odoo_instance.conf" "$config_path"
            if [[ "$domain" == "default" ]]; then
                sed -i 's|__DOMAIN__|*|g' "$config_path"
            else
                sed -i "s|__DOMAIN__|${domain:?}|g" "$config_path"
            fi
            sed -i "s|__CONTAINERNAME__|${name:?}|g" "$config_path"

            if [[ $name != 'default' ]]; then
                # adapt the one yml file and duplicate the odoo service there;
                # removing any ports
                python <<-EOF
import yaml, os
from copy import deepcopy
with open("$docker_compose_file") as f:
    j = yaml.load(f.read())
odoo = deepcopy(j['services']['odoo'])
if 'ports' in odoo:
    del odoo['ports']
odoo['container_name'] = '_'.join([os.environ['DCPREFIX'], "odoo", "$name"])
j['services']['odoo_{}'.format("$name")] = odoo
with open("$docker_compose_file", 'w') as f:
    f.write(yaml.dump(j, default_flow_style=False))
EOF
            fi

        done <"$DIR/run/odoo_instances"
    fi
    return 0
}

function remove_temp_directories() {
    cd "$DIR" || exit -1
    find . -maxdepth 1 -type d|grep -E 'tmp......' | xargs rm {} -Rf \;
}

function setup_proxy() {
    CONFIG_DIR="$DIR/run/proxy"

    find "$DIR/machines" -name 'upstream.path' | while read -r f; do
        content=$(
            envsubst < "$f"
        )
        paths=()

        #extract rewrite rules
        REWRITE_RULES=()
        while read -r line; do
            if echo "$line" | grep -q ^RewriteRule; then
                REWRITE_RULES+=("$line")
            else
                paths+=("$line")
            fi
        done <<< "$content"

        REWRITE_RULES=$(printf "\n%s" "${REWRITE_RULES[@]}")
        REWRITE_RULES=${REWRITE_RULES:1}

        for line in "${paths[@]}"
        do
            local URLPATH
            local MACHINE
            local PORT

            LOCATION=$(echo "$line" | awk '{print $1}')
            UPSTREAM=$(echo "$line" | awk '{print $2}')

            if [[ -z "$LOCATION" || -z "$UPSTREAM" ]]; then
                echo "Invalid: $f"
                echo "Example:   / http://odoo:8072/"
                exit -1
            fi

            if [[ "$(basename $(dirname $f))" == "odoo" ]]; then
                subdir="odoo"
                mkdir -p "$CONFIG_DIR/$subdir"

                if [[ -e "$DIR/run/odoo_instances" ]]; then

                    while read -r line; do
                        name="$(echo "$line"| awk '{print $1}')"
                        domain="$(echo "$line"| awk '{print $2}')"
                        filename="$name.location"
                        CONFIG_PATH="$CONFIG_DIR/$subdir/$filename"
                        if [[ "$name" == "default" ]]; then
                            UPSTREAM_INSTANCE="${UPSTREAM/default/odoo}"
                        else
                            UPSTREAM_INSTANCE=${UPSTREAM/odoo/odoo_$name}
                        fi
                        "$DIR/machines/proxy/add_upstream.sh" "$LOCATION" "$UPSTREAM_INSTANCE" "$CONFIG_PATH" "$REWRITE_RULES"
                    done<"$DIR/run/odoo_instances"
                fi

            else
                subdir="default"
                mkdir -p "$CONFIG_DIR/$subdir"
                filename=${LOCATION//\//_}_${LOCATION//\//_}.location
                CONFIG_PATH="$CONFIG_DIR/$subdir/$filename"
                "$DIR/machines/proxy/add_upstream.sh" "$LOCATION" "$UPSTREAM" "$CONFIG_PATH" "$REWRITE_RULES"
            fi

        done
    done
    return 0
}


function remember_customs_and_cry_if_changed() {
    # if customs changed, then restart is required
    if [[ "$ODOO_MANAGER_STARTED_ONCE" == "1" ]]; then
        return 0
    fi

    current_customs=$(cd "$DIR"; dcexec odoo env | grep "^CUSTOMS=" || echo "")
    current_customs=${current_customs/CUSTOMS=/}

    if [[ -n "$current_customs" && "$current_customs" != "$CUSTOMS" ]]; then
        echo "Customs changed - you need to restart and/or rebuild!"
        sleep 3
        "$MANAGE" kill
    fi

    return 0
}

function main() {
    set -e
    startup "${ARGS[@]}"
    check_working_dir_customs_mismatch
    if [[ "${ARGS[0]}" == "tool" ]]; then

        python "$DIR/admin/module_tools/tool.py" "${ALL_PARAMS[@]@Q}"

    else

        default_confs "${ARGS[@]}"
        export_settings
        remember_customs_and_cry_if_changed
        case $1 in
            build|compose)
                set -e
                remove_temp_directories
                prepare_filesystem
                prepare_yml_files_from_template_files
                reset_proxy_configs
                setup_proxy
                setup_odoo_instances
                ;;

            *)
            ;;
        esac
        sanity_check

        cd "$DIR"
        do_command "${ARGS[@]}"
        cleanup
    fi
}


ARGS=("$@")
main "${ARGS[@]}"
