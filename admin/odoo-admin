#!/usr/bin/python
import sys
import re
import os
import logging
import importlib
import subprocess
import time
import inspect
import yaml
import shutil
import tempfile
import docker
from retrying import retry
from datetime import datetime
from copy import deepcopy
from threading import Thread
from Queue import Queue
from logging import FileHandler
from optparse import OptionParser
import psycopg2
from subprocess import PIPE
from module_tools.myconfigparser import MyConfigParser
from module_tools import odoo_config
from module_tools import odoo_versioning as versioning
from module_tools.odoo_parser import update_cache
from migrate import do_migrate

try:
    from pudb import set_trace
except Exception:
    set_trace = None
current_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) # script directory
sys.path.append(os.path.join(current_dir, 'python_wait'))
import wait

PLATFORM_OSX = "OSX"
PLATFORM_LINUX = "Linux"
YAML_VERSION = '3.3'
BACKUPDIR = "/host/dumps"
COMMANDS = []
FORCE = any(x == '-f' or x == '--force' for x in sys.argv[1:])
args = sys.argv[1:]

dirs = {
    'admin': 'admin',
    'odoo_home': '',
    'proxy_configs_dir': 'run/proxy',
    'settings.d': 'run/settings.d',
    'host_working_dir': '',
    'run': 'run',
    'run/proxy': 'run/proxy',
    'run/restore': 'run/restore',
    'machines': 'machines',
    'machines/proxy': 'machines/proxy',
    'customs': '',
    'telegrambot': 'config/telegrambat',
}

files = {
    'make_customs': 'admin/module_tools/make_customs',
    'docker_compose': 'run/docker-compose.yml',
    'debugging_template': 'config/debugging/template.yml',
    'debugging_composer': 'run/debugging.yml',
    'settings': 'run/settings',
    'odoo_instances': 'run/odoo_instances',
    'config/docker-compose.yml': 'config/docker-compose.yml',
    'run/odoo_debug.txt': 'run/odoo_debug.txt',
    'machines/proxy/odoo_instance.conf': 'machines/proxy/odoo_instance.conf',
    'machines/postgres/turndb2dev.sql': 'machines/postgres/turndb2dev.sql',
}
commands = {
    'dc': ["/usr/local/bin/docker-compose", "-p", "$CUSTOMS", "-f",  "$docker_compose_file"],
}


def trace():
    if set_trace:
        set_trace()

def _get_platform():
    if os.getenv("PLATFORM", "") in ['Darwin', 'OSX']:
        return PLATFORM_OSX
    else:
        return PLATFORM_LINUX

def _startup():
    dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) # script directory
    dir = os.path.dirname(dir)
    dirs['odoo_home'] = dir

    def make_absolute(d):
        for k, v in d.items():
            if not v.startswith('/'):
                d[k] = os.path.join(dir, v)
    make_absolute(dirs)
    make_absolute(files)
    os.environ['ODOO_MANAGER_STARTED_ONCE'] = '1'
    os.environ['ODOO_COMPOSE_VERSION'] = "3.3"
    os.environ['PGPASSFILE'] = "/tmp/.pgpass" # must match the executing script
    os.environ['PGHOST'] = os.path.expandvars("$DB_HOST")
    os.environ['PGPORT'] = os.path.expandvars("$DB_PORT")
    os.environ['PGUSER'] = os.path.expandvars("$DB_USER")
    os.environ['LOCAL_WORKING_DIR'] = "{}/{}".format(os.getenv("EXTERNAL_ROOT"), os.getenv("WORKING_DIR"))  # the working directory accessible from container of this script.
    dirs['host_working_dir'] = os.environ['LOCAL_WORKING_DIR']
    commands['dc'] = [x.replace("$docker_compose_file", files['docker_compose']) for x in commands['dc']]

def __assert_file_exists(path, isdir=False):
    if not os.path.exists(path):
        raise Exception("{} {} not found!".format(
            'Directory' if isdir else 'File',
            path
        ))

def __do_restore_db_on_postgres(filename, dbname):
    os.environ['DBNAME'] = dbname
    dump_file = os.path.join(BACKUPDIR, filename)

    __assert_file_exists(dump_file)

    print("Restoring dump on {}".format(E("DB_HOST")))
    __print_env(['DB_HOST', 'DB_PORT', 'DB_USER'])
    os.environ['PGPASSWORD'] = E("DB_PWD")
    args = ["-h", "$DB_HOST", "-p", "$DB_PORT", "-U", "$DB_USER"]
    args = [os.path.expandvars(x) for x in args]
    PGRESTORE = [
        "pg_restore",
        "--no-owner",
        "--no-privileges",
        "--no-acl",
    ] + args
    PSQL = ["psql"] + args

    __execute_sql("drop database if exists {}".format(dbname), 'template1', notransaction=True)
    __execute_sql("create database {}".format(dbname), 'template1', notransaction=True)

    method = PGRESTORE
    needs_unzip = True

    dump_type = __get_dump_type(dump_file)
    if dump_type == 'plain_text':
        needs_unzip = False
        method = PSQL
    elif dump_type == 'zipped_sql':
        method = PSQL
        needs_unzip = True
    elif dump_type == "zipped_pgdump":
        pass
    elif dump_type == "unzipped_pgdump":
        needs_unzip = False
    else:
        raise Exception("not impl: {}".format(dump_type))

    if needs_unzip:
        unzipper = subprocess.Popen(["/bin/gunzip", "-c", dump_file], stdout=PIPE)
        stdin = unzipper.stdout
    else:
        catter = subprocess.Popen(["/bin/cat", dump_file], stdout=PIPE)
        stdin = catter.stdout
    started = datetime.now()
    print "Restoring DB..."
    subprocess.check_call(method + [
        '-d',
        E("DBNAME"),
    ], stdin=stdin, env=os.environ),
    print "Restore took {} seconds".format((datetime.now() - started).seconds)

def __do_restore_files(filepath):
    # remove the postgres volume and reinit
    if filepath.startswith("/"):
        raise Exception("No absolute path allowed")
    dcrun(['odoo', '/bin/restore_files.sh', os.path.basename(filepath)])

def __empty_dir(dir):
    if os.path.isdir(dir):
        for f in os.listdir(dir):
            filepath = os.path.join(dir, f)
            if os.path.isdir(filepath):
                __rmtree(filepath)
            else:
                os.unlink(filepath)

def __execute_sql(sql, dbname=None, fetchone=False, fetchall=False, notransaction=False, no_try=False):
    if not dbname:
        dbname = E("DBNAME")

    # try to connecto to postgres; could startup:
    @retry(wait_random_min=500, wait_random_max=800, stop_max_delay=30000)
    def try_connect():
        __execute_sql("SELECT * FROM pg_catalog.pg_tables;", 'template1', no_try=True)
    if not no_try:
        try_connect()

    conn = psycopg2.connect(
        dbname=dbname,
        user=E("DB_USER"),
        password=E("DB_PWD"),
        host=E("DB_HOST"),
        port=E("DB_PORT"),
    )
    conn.autocommit = notransaction
    result = None
    cr = conn.cursor()
    try:
        cr.execute(sql)
        if fetchone:
            result = cr.fetchone()
        elif fetchall:
            result = cr.fetchall()
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        cr.close()
        conn.close()
    return result

def __exists_db(dbname):
    dbname = dbname or E("DBNAME")
    sql = "select count(*) from pg_database where datname='{}'".format(dbname)
    record = __execute_sql(sql, fetchone=True, dbname='template1')
    if not record or not record[0]:
        return False
    return True

def __file_default_content(path, default_content):
    if not os.path.exists(path):
        with open(path, 'w') as f:
            f.write(default_content)

def __file_get_lines(path):
    with open(path) as f:
        return f.readlines()

def __get_docker_compose_run_command():
    """
    Returns bash ready command to call simplebash self by run.

    """
    host_odoo_home = os.environ["ODOO_HOME"]
    local_odoo_home = os.environ['LOCAL_ODOO_HOME']
    cmdline = []
    cmdline.append("/opt/docker/docker")
    cmdline.append("run")
    cmdline.append('-e')
    cmdline.append('ODOO_HOME={}'.format(host_odoo_home))
    envfile = os.path.join(local_odoo_home, 'run/settings')
    if os.path.exists(envfile):
        cmdline.append('--env-file')
        cmdline.append(envfile)
    cmdline.append("--rm")
    cmdline.append('-v')
    cmdline.append("{HOST_ODOO_HOME}:{HOST_ODOO_HOME}".format(HOST_ODOO_HOME=os.environ["ODOO_HOME"]))
    cmdline.append("--workdir")
    cmdline.append(host_odoo_home)
    cmdline.append(__get_docker_image())
    return cmdline

def _setup_proxy():
    CONFIG_DIR = dirs['run/proxy']

    sys.path.append(dirs['machines/proxy'])
    importlib.import_module("add_upstream")
    from add_upstream import add_upstream as f_add_upstream

    def get_rules():
        for root, _, _filenames in os.walk(dirs['machines']):
            for filename in _filenames:
                if filename == 'upstream.path':
                    filepath = os.path.join(root, filename)
                    with open(filepath, 'r') as f:
                        for l in f.readlines():
                            if l:
                                yield filepath, l

    for filepath, rule in get_rules():
        rule = os.path.expandvars(rule)

        LOCATION, UPSTREAM = rule.strip().split(" ")

        if not LOCATION or not UPSTREAM:
            raise Exception("Invalid rule: {}".format(rule))

        parent_dir = os.path.dirname(filepath)
        if os.path.basename(parent_dir) == "odoo":
            subdir = "odoo"
            __makedirs(os.path.join(CONFIG_DIR, subdir))

            if os.path.exists(files['odoo_instances']):
                for line in __file_get_lines(files['odoo_instances']):
                    name, domain = line.strip().split(" ")
                    filename = "{}.location".format(name)
                    CONFIG_PATH = os.path.join(CONFIG_DIR, subdir, filename)
                    if name == "default":
                        UPSTREAM_INSTANCE = UPSTREAM.replace("default", "odoo")
                    else:
                        UPSTREAM_INSTANCE = UPSTREAM.replace("odoo", "odoo_{}".format(name))
                    f_add_upstream(LOCATION, UPSTREAM_INSTANCE, CONFIG_PATH)

        else:
            subdir = "default"
            __makedirs(os.path.join(CONFIG_DIR, subdir))
            safe_location = LOCATION.replace("\\", "_").replace("/", "")
            filename = "{location}_{location}.location".format(location=safe_location)
            CONFIG_PATH = os.path.join(CONFIG_DIR, subdir, filename)
            f_add_upstream(LOCATION, UPSTREAM, CONFIG_PATH)

def __get_docker_image():
    hostname = os.environ['HOSTNAME']
    result = [x for x in __system(["/opt/docker/docker", "inspect", hostname], suppress_out=True).split("\n") if "\"Image\"" in x]
    if result:
        result = result[0].split("sha256:")[-1].split('"')[0]
        return result[:12]
    raise Exception("Image not determined")

def __get_dump_type(filepath):
    temp = tempfile.mktemp(suffix='.check')
    os.system('gunzip -c "{}" | head > "{}" 2>/dev/null'.format(filepath, temp))
    MARKER = "PostgreSQL database dump"

    if os.path.exists(temp):
        content = __read_file(temp)
        if MARKER in content:
            return 'zipped_sql'
        if content.startswith("PGDMP"):
            return "zipped_pgdump"
    with open(filepath, 'r') as f:
        for i, line in enumerate(f):
            if i == 0 and line.startswith("PGDMP"):
                return 'pgdump'
            if i > 50:
                break
            if MARKER in line:
                return "plain_text"
    return 'unzipped_pgdump'

def __is_container_running(machine_name):
    out = dc(['ps', '-q', machine_name], raise_exception=False, suppress_out=True)
    return bool(out)

def __makedirs(path):
    if not os.path.exists(path):
        os.makedirs(path)

def __print_env(vars):
    for x in vars:
        print "{}: {}".format(x, E(x))

def __read_file(path):
    with open(path, 'r') as f:
        return f.read()

def __remove_postgres_connections(DBNAME=None):
    DBNAME = DBNAME or E("DBNAME")
    print "Removing all current connections"
    if __exists_db(DBNAME):
        SQL = """
            SELECT pg_terminate_backend(pg_stat_activity.pid)
            FROM pg_stat_activity
            WHERE pg_stat_activity.datname = '{}'
            AND pid <> pg_backend_pid();
        """.format(DBNAME)
        __execute_sql(SQL, 'template1', notransaction=True)

def __rename_db_drop_target(from_db, to_db):
    if 'to_db' == 'template1':
        raise Exception("Invalid: {}".format(to_db))
    __remove_postgres_connections(from_db)
    __remove_postgres_connections(to_db)
    __execute_sql("drop database if exists {to_db}".format(**locals()), "template1", notransaction=True)
    __execute_sql("alter database {from_db} rename to {to_db};".format(**locals()), "template1", notransaction=True)
    __remove_postgres_connections(to_db)

def __replace_in_file(filepath, text, replacewith):
    with open(filepath, 'r') as f:
        content = f.read()
    content = content.replace(text, replacewith)
    with open(filepath, 'w') as f:
        f.write(content)

def __reset_postgres_container():
    # remove the postgres volume and reinit
    if E("RUN_POSTGRES") == "1":
        print "Resettings postgres - killing data - not reversible"
        do_command("kill")
        dc(["rm", "-f"]) # set volume free
        VOLUMENAME = "{}_postgresdata".format(E("CUSTOMS"))
        docker_client = docker.from_env()

        @retry(wait_random_min=500, wait_random_max=800, stop_max_delay=30000)
        def remove_volume():
            for volume in docker_client.volumes.list():
                if volume.name == VOLUMENAME:
                    volume.remove()
            return True
        remove_volume()
        dcrun(['-e', 'INIT=1', 'postgres', '/entrypoint2.sh'])
        __start_postgres_and_wait()

def __restore_check(filepath):
    dumpname = os.path.basename(filepath)

    if E("DBNAME") not in dumpname and not FORCE:
        raise Exception("The dump-name \"{}\" should somehow match the current database \"{}\", which isn't.".format(
            dumpname,
            E("DBNAME"),
        ))

def __rm_file_if_exists(path):
    if os.path.exists(path):
        os.unlink(path)

def __rmtree(path):
    if not path or path == '/':
        raise Exception("Not allowed: {}".format(path))
    if not path.startswith("/"):
        raise Exception("Not allowed: {}".format(path))
    if not any(path.startswith(dirs['odoo_home'] + x) for x in ['/tmp', '/run/']):
        raise Exception('not allowed')
    shutil.rmtree(path)

def __safeget(array, index, exception_on_missing, file_options=None):
    if file_options:
        if os.path.exists(file_options):
            file_options = '\n' + '\n'.join(os.listdir(file_options))
    file_options = file_options or ''
    if len(array) < index + 1:
        raise Exception(exception_on_missing + file_options)
    return array[index]

def __start_postgres_and_wait():
    if E("RUN_POSTGRES") == "1":
        dc(["up", "-d", "postgres"])
        __wait_for_port(E("DB_HOST"), long(E("DB_PORT")), timeout=30)
        __execute_sql("""
        SELECT table_schema,table_name
        FROM information_schema.tables
        ORDER BY table_schema,table_name;
        """, dbname='template1')

def __set_db_ownership():
    # in development environments it is safe to set ownership, so
    # that accidently accessing the db fails
    if E("DEVMODE") == "1":
        if E("RUN_POSTGRES") == "1":
            __start_postgres_and_wait()
        from module_tools.module_tools import set_ownership_exclusive
        set_ownership_exclusive()

def __system(cmd, cwd=None, suppress_out=False, raise_exception=True, wait_finished=True, shell=False):
    assert isinstance(cmd, list)

    STDPIPE, ERRPIPE, bufsize = subprocess.PIPE, subprocess.PIPE, 1
    if not wait_finished:
        STDPIPE, ERRPIPE, bufsize = None, None, -1
    proc = subprocess.Popen(cmd, shell=shell, stdout=STDPIPE, stderr=ERRPIPE, bufsize=bufsize, cwd=cwd)

    def reader(pipe, q):
        try:
            with pipe:
                for line in iter(pipe.readline, ''):
                    q.put((pipe, line))
        finally:
            q.put(None)
    if wait_finished:
        err = proc.stderr
        out = ""
        q = Queue()
        Thread(target=reader, args=[proc.stdout, q]).start()
        Thread(target=reader, args=[proc.stderr, q]).start()
        for source, line in iter(q.get, None):
            if source != err:
                out += line
            if not suppress_out:
                sys.stdout.write(line)
                sys.stdout.flush()

    if not wait_finished:
        return
    proc.wait()
    if proc.returncode and raise_exception:
        raise Exception("Error executing: {}".format(" ".join(cmd)))
    return out

def __try_to_set_owner(UID, path, recursive=False):
    if os.path.isdir(path):
        uid = os.stat(path).st_uid
        if str(uid) != str(UID) or recursive:
            print("Trying to set correct permissions on {}".format(path))
            options = ""
            if recursive:
                options += "-R"
            __system([
                'chown',
                options,
                UID,
                path
            ])

def __turn_into_devdb(dbname):
    SQLFILE = files['machines/postgres/turndb2dev.sql']
    sql = __read_file(SQLFILE)
    __execute_sql(sql, dbname=dbname)

def __wait_for_port(host, port, timeout=None):
    res = wait.tcp.open(port, host=host, timeout=timeout)
    if not res and timeout:
        raise Exception("Timeout elapsed waiting for {}:{}".format(host, port))

def _askcontinue(msg=None):
    if msg:
        print(msg)
    if FORCE or os.getenv("FORCE_CONTINUE", "0") == "1":
        return
    raw_input("Continue? (Ctrl+C to break)")

def _check_working_dir_customs_mismatch():
    # Checks wether the current working is in a customs directory, but
    # is not matching the correct customs. Avoid creating wrong tickets
    # in the wrong customizations.

    working_dir = dirs['host_working_dir']
    while not os.path.isfile(os.path.join(working_dir, '.customsroot')):
        try:
            working_dir = os.path.dirname(working_dir)
        except Exception:
            break
        if not working_dir.replace("/", ""):
            break

    if os.path.isfile(os.path.join(working_dir, '.customsroot')):
        current_customs = os.path.basename(working_dir)
        if current_customs != os.environ['CUSTOMS']:
            _askcontinue("""Caution: current customs is {} but you are in another customs directory: {}
Continue at your own risk!""".format("$CUSTOMS", "$LOCAL_WORKING_DIR")
                         )


def _cleanup():
    __rm_file_if_exists(files['config/docker-compose.yml'])
    _remove_temp_directories

def _collect_settings_files():
    _files = []
    _files.append(os.path.join(dirs['odoo_home'], 'machines/defaults'))
    for root, _, _filenames in os.walk(dirs['machines']):
        for filename in _filenames:
            if filename == 'default.settings':
                _files.append(os.path.join(root, filename))
    customs_dir = odoo_config.customs_dir()
    if os.path.exists(os.path.join(customs_dir, 'settings')):
        _files.append(os.path.join(customs_dir, 'settings'))
    if os.path.exists('/etc_host/odoo/settings'):
        _files.append('/etc_host/odoo/settings')
    if os.path.exists('/etc_host/odoo/{}/settings'.format(os.environ['CUSTOMS'])):
        _files.append('/etc_host/odoo/{}/settings'.format(os.environ['CUSTOMS']))
    if os.path.isdir(dirs['settings.d']):
        for filename in os.listdir(dirs['settings.d']):
            filepath = os.path.join(dirs['settings.d'], filename)
            if os.path.exists(filepath):
                _files.append(filepath)
    return _files

def _display_machine_tips(machine_name):
    dir = os.path.join(dirs['machines'], machine_name)
    if not os.path.isdir(dir):
        return

    for root, _dirs, _files in os.walk(dirs['machines']):
        for filename in _files:
            if filename == 'tips.txt':
                if os.path.basename(root) == 'machine_name':
                    content = __read_file(os.path.join(root, filename))
                    print ""
                    print "Please note:"
                    print "---------------"
                    print ""
                    print content
                    print ""
                    print ""

def _export_settings():
    if args and args[0] == 'compose':
        if len(args) > 1:
            customs = args[1]
            if os.path.isfile(files['settings']):
                os.unlink(files['settings'])
            config = MyConfigParser(files['settings'])
            config['CUSTOMS'] = customs
            config.write()
    _file2env(files['settings'])

    if not os.path.exists(files['settings']):
        raise Exception("Please call ./odoo compose <CUSTOMS> initially.")

    # get odoo version
    ODOO_VERSION = str(odoo_config.get_version_from_customs(os.environ['CUSTOMS']))
    os.environ['ODOO_VERSION'] = ODOO_VERSION
    if ODOO_VERSION in ["6.0", "6.1", "7.0", "8.0", "9.0"]:
        os.environ['ODOO_PYTHON_VERSION'] = '2'
        os.environ['ODOO_EXECUTABLE'] = 'openerp-server'
    elif ODOO_VERSION in ["10.0"]:
        os.environ['ODOO_PYTHON_VERSION'] = '2'
        os.environ['ODOO_EXECUTABLE'] = 'odoo-bin'
    elif ODOO_VERSION in ['11.0']:
        os.environ['ODOO_PYTHON_VERSION'] = '3'
        os.environ['ODOO_EXECUTABLE'] = 'odoo-bin'
    else:
        raise Exception("not impl: {}".format(ODOO_VERSION))

    setting_files = _collect_settings_files()
    _make_settings_file(files['settings'], setting_files)
    config = MyConfigParser(files['settings'])

    if "DBNAME" not in config.keys():
        config['DBNAME'] = config['CUSTOMS']
        config.write()
    if "ODOO_VERSION" not in config or config['ODOO_VERSION'] != ODOO_VERSION:
        config['ODOO_VERSION'] = ODOO_VERSION
        config.write()

    # store the host root folder
    config['HOST_ODOO_HOME'] = E("ODOO_HOME")
    _file2env(files['settings'])

def _file2env(filepath):
    if not os.path.exists(filepath):
        return
    config = MyConfigParser(filepath)
    for k in config.keys():
        os.environ[k] = config[k]

def _get_bash_for_machine(machine):
    if machine == 'postgres':
        return 'gosu postgres bash'
    else:
        return 'bash'

def _make_settings_file(outfile, setting_files):
    """
    Puts all settings into one settings file
    """
    c = MyConfigParser(outfile)
    for file in setting_files:
        if not file:
            continue
        c2 = MyConfigParser(file)
        c.apply(c2)
    c.write()

def _prepare_docker_compose_files(dest_file, paths):
    local_odoo_home = os.environ['LOCAL_ODOO_HOME']

    temp_files = set()
    tempdir = tempfile.mkdtemp()

    if not dest_file:
        raise Exception('require destination path')

    with open(dest_file, 'w') as f:
        f.write("#Composed {}\n".format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        f.write("version: '{}'\n".format(os.environ['ODOO_COMPOSE_VERSION']))

    def replace_all_envs_in_file(filepath):
        with open(filepath, 'r') as f:
            content = f.read()
        all_params = re.findall(r'\$\{[^\}]*?\}', content)
        for param in all_params:
            name = param
            name = name.replace("${", "")
            name = name.replace("}", "")
            if name in os.environ:
                content = content.replace(param, os.environ[name])
        with open(filepath, 'w') as f:
            f.write(content)

    for path in set(paths):
        filename = os.path.basename(path)

        def use_file():
            if 'run_' in filename:
                run = re.findall(r'run_[^\.]*', filename)
                if run:
                    if os.getenv(run[0].upper(), "1") == "1":
                        return True
                return False
            else:
                return True

        if not use_file():
            continue

        with open(path, 'r') as f:
            content = f.read()
            # dont matter if written manage-order: or manage-order
            if 'manage-order' not in content:
                order = '99999999'
            else:
                order = content.split("manage-order")[1].split("\n")[0].replace(":", "").strip()
        folder_name = os.path.basename(os.path.dirname(path))
        if os.getenv("RUN_{}".format(folder_name.upper()), "1") == "0":
            continue

        order = str(order)

        # put all files in their order into the temp directory
        counter = 0
        temp_path = ""
        while not temp_path or os.path.exists(temp_path):
            counter += 1
            temp_path = os.path.join(tempdir, '{}-{}'.format(order, str(counter).zfill(5)))

        with open(temp_path, 'w') as dest:
            with open(path, 'r') as source:
                j = yaml.load(source.read())
                # TODO complain version - override version
                j['version'] = YAML_VERSION

                # set settings environment and the override settings after that
                for file in ['run/settings']:
                    path = os.path.join(local_odoo_home, file)
                    if os.path.exists(path):
                        if 'services' in j:
                            for service in j['services']:
                                service = j['services'][service]
                                if 'env_file' not in service:
                                    service['env_file'] = []
                                if isinstance(service['env_file'], (str, unicode)):
                                    service['env_file'] = [service['env_file']]

                                if not [x for x in service['env_file'] if x == '$ODOO_HOME/{}'.format(file)]:
                                    service['env_file'].append('$ODOO_HOME/{}'.format(file))

                dest.write(yaml.dump(j, default_flow_style=False))
                dest.write("\n")
        replace_all_envs_in_file(temp_path)
        temp_files.add(os.path.basename(temp_path))
        del temp_path

    def post_process_complete_yaml_config(yml):
        """
        This is after calling docker-compose config, which returns the
        complete configuration.

        Aim is to take the volumes defined in odoo_base and append them
        to all odoo containers.
        """

        with open(os.path.join(local_odoo_home, 'machines/odoo/docker-compose.yml')) as f:
            odoodc = yaml.load(f.read())

        for odoomachine in odoodc['services']:
            if odoomachine == 'odoo_base':
                continue
            machine = yml['services'][odoomachine]
            for k in ['volumes']:
                machine[k] = []
                for x in yml['services']['odoo_base'][k]:
                    machine[k].append(x)
            for k in ['environment']:
                machine.setdefault(k, {})
                for x, v in yml['services']['odoo_base'][k].items():
                    machine[k][x] = v
        yml['services'].pop('odoo_base')

        return yml

    # call docker compose config to get the complete config
    files = sorted(temp_files, key=lambda x: float(x.split("/")[-1].replace("-", ".")))
    cmdline = __get_docker_compose_run_command()
    cmdline.append("/usr/local/bin/docker-compose")
    for file in files:
        cmdline.append('-f')
        cmdline.append(os.path.join(os.path.basename(tempdir), file))
    cmdline.append('config')

    # annotation: per symlink all subfiles/folders are linked to a path,
    # that matches the host system path
    shutil.move(tempdir, local_odoo_home)
    tempdir = os.path.join(local_odoo_home, os.path.basename(tempdir))

    try:
        conf = __system(cmdline, cwd=local_odoo_home, suppress_out=True)
    except Exception:
        raise
    else:
        # post-process config config
        conf = post_process_complete_yaml_config(yaml.load(conf))
        conf = yaml.dump(conf, default_flow_style=False)

        with open(dest_file, 'w') as f:
            f.write(conf)
    finally:
        __rmtree(tempdir)

def _prepare_yml_files_from_template_files():
    # replace params in configuration file
    # replace variables in docker-compose;

    if E("ODOO_MANAGER_STARTED_ONCE") != "1":
        for name in ['CUSTOMS', 'DB', 'ODOO_VERSION', 'ODOO_FILES']:
            print("{}: {}".format(name, E(name)))

    # python: find all configuration files from machines folder; extract sort
    # by manage-sort flag and put file into run directory
    # only if RUN_parentpath like RUN_ODOO is <> 0 include the machine
    #
    # - also replace all environment variables
    def find_files(dir):
        PATTERN = r'docker-compose.*.yml'
        for root, _, _filenames in os.walk(dirs['machines']):
            for filename in _filenames:
                if re.findall(PATTERN, filename):
                    yield os.path.join(root, filename)
    _files = []
    _files += find_files(dirs['machines'])
    _files += find_files(odoo_config.customs_dir())

    _prepare_docker_compose_files(files['docker_compose'], _files)

def _remember_customs_and_cry_if_changed():
    # if customs changed, then restart is required

    out = dcexec(['odoo env'])
    out = [x for x in out.split('\n') if "CUSTOMS="]
    if out:
        current_customs = out[0].split("=")[-1]
        if current_customs != os.environ['CUSTOMS']:
            print("Customs changed - you need to restart and/or rebuild!")
            do_command('kill')

def _remove_temp_directories():
    for dir in os.listdir(dirs['odoo_home']):
        if dir.startswith("tmp") and len(dir) == len('tmp......'):
            __rmtree(os.path.join(dirs['odoo_home'], dir))

def _reset_proxy_configs():
    __empty_dir(dirs['run/proxy'])

def _prepare_filesystem():
    __makedirs(dirs['settings.d'])
    for subdir in ['config', 'sqlscripts', 'debug', 'proxy']:
        __makedirs(os.path.join(dirs['odoo_home'], 'run', 'subdir'))
    __system(['sudo', '-E', 'chown', "{uid}:{uid}".format(uid=E("UID")), "-R", dirs['run']])

    __file_default_content(files['odoo_instances'], "default default\n")

def _sanity_check():
    if not E("RUN_POSTGRES"):
        raise Exception("Please define RUN_POSTGRES")

    if E("RUN_POSTGRES") == "1" and E("DB_HOST") != "postgres":
        print("You are using the docker postgres container, but you do not have the DB_HOST set to use it.")
        print("Either configure DB_HOST to point to the docker container or turn it off by: ")
        print("RUN_POSTGRES=0")
        sys.exit(1)

    if E("OWNER_UID") == "0":
        print("Advise: you should set OWNER_UID so that dump files are marked as the correct owner")
        time.sleep(3)

    if E("ODOO_FILES") and os.path.isdir(E("ODOO_FILES")):
        # checking directory permissions of session files and filestorage
        __try_to_set_owner(E("OWNER_UID"), E("$ODOO_FILES"))

    # make sure the odoo_debug.txt exists; otherwise directory is created
    __file_default_content(files['run/odoo_debug.txt'], "")

    if not E("ODOO_MODULE_UPDATE_RUN_TESTS"):
        print("Please define wether to run tests on module updates by setting ODOO_MODULE_UPDATE_RUN_TESTS")
        time.sleep(2)


def _setup_odoo_instances():
    if os.path.exists(files['odoo_instances']):
        __empty_dir(dirs['proxy_configs_dir'])

        if os.path.exists(files['odoo_instances']):
            for line in __file_get_lines(files['odoo_instances']):
                name, domain = line.strip().split(" ")
                config_path = os.path.join(dirs['proxy_configs_dir'], "{}.host".format(name))
                shutil.copy(files['machines/proxy/odoo_instance.conf'], config_path)
                if domain == "default":
                    __replace_in_file(config_path, "__DOMAIN__", "*")
                else:
                    if domain:
                        __replace_in_file(config_path, "__DOMAIN__", domain)
            if name:
                __replace_in_file(config_path, "__CONTAINERNAME__", name)

            if name != "default":
                # adapt the one yml file and duplicate the odoo service there;
                # removing any ports
                with open(files['docker_compose_file']) as f:
                    j = yaml.load(f.read())
                odoo = deepcopy(j['services']['odoo'])
                if 'ports' in odoo:
                    del odoo['ports']
                odoo['container_name'] = '_'.join([os.environ['CUSTOMS'], "odoo", name])
                j['services']['odoo_{}'.format(name)] = odoo
                with open(files['docker_compose_file'], 'w') as f:
                    f.write(yaml.dump(j, default_flow_style=False))

def _showhelp():

    print "Available Commands:"
    for command in sorted(commands):
        C = commands[command]
        print command
        if C.__doc__:
            print C.__doc__
    return

def __get_cmd():
    cmd = commands['dc']
    cmd = [os.path.expandvars(x) for x in cmd]
    return cmd

def dcexec(cmd):
    c = __get_cmd()
    c = c + ['exec', '-T'] + cmd
    out = __system(c, cwd=dirs['odoo_home'])
    return out

def dc(cmd, suppress_out=False, raise_exception=True, wait_finished=True):
    c = __get_cmd() + cmd
    out = __system(
        c,
        cwd=dirs['odoo_home'],
        suppress_out=suppress_out,
        raise_exception=raise_exception,
        wait_finished=wait_finished,
    )
    return out

def dcrun(cmd, interactive=False, wait_finished=True):
    cmd = [os.path.expandvars(x) for x in cmd]
    if interactive:
        options = ''
    else:
        options = '-T'
    cmd = ['run', '--rm', options, '-e ODOO_HOME=/opt/odoo'] + cmd
    return dc(cmd, wait_finished=wait_finished)

def E(name):
    if name.startswith("$"):
        name = name[1:]
    return os.getenv(name, "")

def command_abort_upgrade(command_parameters, command_options):
    SQL = """
        UPDATE ir_module_module SET state = 'installed' WHERE state = 'to upgrade';
        UPDATE ir_module_module SET state = 'uninstalled' WHERE state = 'to install';
    """
    __execute_sql(SQL)

def command_attach(command_parameters, command_options):
    """
    attaches to running machine
    """
    machine = __safeget(command_parameters, 0, "Please give machine name as second parameter e.g. postgres, odoo")
    machine == command_parameters[0]
    _display_machine_tips(machine)
    bash = _get_bash_for_machine(machine)
    cmd = __get_cmd() + ['exec', machine, bash]
    os.system(" ".join(cmd))

def command_backup(command_parameters, command_options):
    """"
    Runs backup-db and backup-files
    """
    do_command("backup-db")
    do_command("backup-files")

def command_backup_db(command_parameters, command_options):
    if command_parameters:
        filename = command_parameters[0]
    else:
        filename = datetime.now().strftime("{} %Y-%m-%d_%H%M%S.dump.gz".format(E("CUSTOMS")))

    if filename.startswith("/"):
        raise Exception("No slash for backup filename allowed")
    print "Databasename is " + E("DBNAME")
    filepath = os.path.join(BACKUPDIR, filename)
    if os.path.exists(filepath):
        os.unlink(filepath)
    LINKPATH = os.path.join(BACKUPDIR, 'latest_dump')
    __start_postgres_and_wait()
    os.system('pg_dump -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -Z0 -Fc "$DBNAME" | pigz --rsyncable > "{}"'.format(filepath))
    if E("NO_BACKUP_SYMBOLIC_LINK_DUMP") != "1":
        if os.path.islink(LINKPATH) or os.path.exists(LINKPATH):
            os.unlink(LINKPATH)
        __system([
            'ln',
            '-s',
            os.path.basename(filepath),
            os.path.basename(LINKPATH)
        ], cwd=os.path.dirname(filepath))
    print "Dumped to ", filepath
    do_command('telegram-send', ["Database Backup $DBNAME done to $filepath"])


def command_backup_files(command_parameters, command_options):
    if command_parameters:
        raise Exception("No parameters allowed")
    BACKUP_FILENAME = "{CUSTOMS}.files.tar.gz".format(CUSTOMS=E("CUSTOMS"))

    if os.path.exists(BACKUP_FILENAME):
        second = BACKUP_FILENAME + ".bak"
        if os.path.exists(second):
            os.unlink(second)
        shutil.move(BACKUP_FILENAME, second)
    dcrun(["odoo", "/backup_files.sh", BACKUP_FILENAME])
    print "Backup files done to {}".format(BACKUP_FILENAME)

def command_build(command_parameters, command_options):
    """
    no parameter all machines, first parameter machine name and passes other params; e.g. ./odoo build asterisk --no-cache"
    """
    do_command("compose")
    dc(['build'] + command_parameters)

def command_commit(comman_parameters, command_options):
    versioning.actions["commit"](*command_parameters)

def command_compose(command_parameters, command_options):
    """
    - builds docker compose
    - builds proxy settings
    - setups odoo instances
    """
    _remove_temp_directories()
    _prepare_filesystem()
    _prepare_yml_files_from_template_files()
    _reset_proxy_configs()
    _setup_proxy()
    _setup_odoo_instances()
    print "Built the docker-compose file."

def command_current_ticket(comman_parameters, command_options):
    versioning.actions["current-ticket"](*command_parameters)

def command_debug(command_parameters, command_options):
    """
    starts /bin/bash for just that machine and connects to it; if machine is down, it is powered up; if it is up, it is restarted; as command an endless bash loop is set"
    """

    # puts endless loop into container command and then attaches to it;
    # by this, name resolution to the container still works
    machine_name = __safeget(command_parameters, 0, "Please give machine name as second parameter e.g. postgres, odoo")
    __set_db_ownership()
    _askcontinue("Current machine {} is dropped and restartet with service ports in bash. Usually you have to type /debug.sh then.".format(machine_name))
    # shutdown current machine and start via run and port-mappings the replacement machine
    do_command("kill", [machine_name])
    shutil.copy(file['debugging_template'], file['debugging_composer'])
    __replace_in_file(file['debugging_composer'], "${CUSTOMS}", E("CUSTOMS"))
    __replace_in_file(file['debugging_composer'], "${NAME}", machine_name)
    commands['dc'] += ['-f', file['debugging_composer']]

    # execute self
    dc(['up', '-d', machine_name])
    dcexec([machine_name, 'bash'])

def command_deploy(command_parameters, command_options):
    versioning.action_deploy_ticket()

def command_deploy_ticket(comman_parameters, command_options):
    versioning.actions["deploy-ticket"](*command_parameters)

def command_dev(command_parameters, command_options):
    """
    starts developing in the odoo container
    """
    if command_parameters:
        do_command('compose', command_parameters)
    do_command('kill')
    do_command('rm', ['-f'])
    do_command('build')
    do_command('up', ['-d'])
    do_command('attach', ['odoo'])

def command_dirty(command_parameters, command_options):
    versioning.dirty()
def command_exec(command_parameters, command_options):
    dcexec(command_parameters)

def command_export_i18n(command_parameters, command_options):
    LANG = __safeget(command_parameters, 0, "Please provide lang")
    MODULES = __safeget(command_parameters, 1, "Please provide module")
    dcrun(['odoo', '/export_i18n.sh', LANG, MODULES])
    # file now is in $DIR/run/i18n/export.po

def command_fix_permissions(command_parameters, command_options):
    if E("ODOO_FILES") and os.path.isdir(E("ODOO_FILES")) and E("OWNER_UID") and E("OWNER_UID") != "0":
        __try_to_set_owner(E("OWNER_UID", E("ODOO_FILES"), recursive=True))
    customs_dir = odoo_config.customs_dir()
    __try_to_set_owner("1000", customs_dir, recursive=True) # so odoo user has access

def command_force_kill(command_parameters, command_options):
    machine_name = __safeget(command_parameters, 0, "Please provide machine name")
    dc(['kill', machine_name])

def command_get_all_langs(command_parameters, command_options):
    langs = [x[0] for x in __execute_sql(
        "select code from res_lang;",
        fetchall=True
    )]
    for lang in langs:
        print(lang)
    return langs

def command_kill(command_parameters, command_options):
    """
    kills running machine
    safely shutdowns postgres and redis
    """
    machine_name = command_parameters[0] if command_parameters else None
    if not machine_name or machine_name == 'redis':
        if __is_container_running('redis'):
            dc(["stop", "-t 20", "redis"])  # persist data

    if not command_parameters:
        if __is_container_running('postgres'):
            dc(["stop", "-t 20", "postgres"])  # persist data
    dc(['stop', '-t 10'] + command_parameters)

def command_incversions(comman_parameters, command_options):
    versioning.actions["incversions"](*command_parameters)

def command_link(command_parameters, command_options):
    """
    links all modules into ./links
    """
    __system([
        'python',
        os.path.join(dirs['admin'], 'link_modules')
    ])

def command_logsn(command_parameters, command_options):
    """
    logoutput of machine; use parameter for machine
    """
    dc(['logs', '--tail=' + command_parameters[0], '-f', '-t'] + command_parameters[1:])

def command_logs(command_parameters, command_options):
    lines = 0
    if len(command_parameters) >= 2:
        lines = long(command_parameters[1])
    machine_name = command_parameters[0] if command_parameters else None
    if lines:
        print "Showing last {}lines".format(lines)

    cmd = ['logs', '-f', '-t']
    if lines:
        cmd += ['--tail={}'.format(lines)]
    if machine_name:
        cmd += [machine_name]
    dc(cmd)

def command_logall(command_parameters, command_options):
    dc(['logs', '-f', '-t'] + command_parameters)

def command_import_i18n(command_parameters, command_options):
    dcrun(['odoo', '/import_i18n.sh'] + command_parameters)

def command_make_customs(command_parameters, command_options):
    _askcontinue()
    admin_dir = dirs['admin']
    do_command('kill')
    CUSTOMS = __safeget(command_parameters, 0, 'Please provide customs')
    VERSION = __safeget(command_parameters, 1, "Please provide version")
    __system([
        file['make_customs'],
        CUSTOMS,
        VERSION
    ])
    os.environ['CUSTOMS'] = CUSTOMS
    cwd = os.path.join(dirs['odoo_home'], 'customs', CUSTOMS)
    __system([
        file['make_customs'],
        "git",
        "submodule",
        "add",
        "https://github.com/odoo/odoo odoo"
    ], cwd=cwd)
    odoo_dir = os.path.join(cwd, 'odoo')
    __system([
        'git', 'checkout', str(VERSION)
    ], cwd=odoo_dir)
    __system([
        'git', 'checkout', str(VERSION)
    ], cwd=admin_dir)
    __system([
        "OCA-all"
    ], cwd=admin_dir)
    __system([
        "odoo-submodule",
        'tools,web_modulesroduct_modules,calendar_ics',
    ], cwd=admin_dir)
    do_command('kill')
    do_command('compose', [CUSTOMS])
    do_command('up', ['-d'])

def command_OCA(command_parameters, command_options):
    __system([
        file['make_customs'],
        "OCA-all"
    ] + command_parameters, cwd=dirs['admin'])

def command_mergeto(comman_parameters, command_options):
    versioning.actions["mergeto"](*command_parameters)

def command_migrate(command_parameters, command_options):
    LOGFILE = os.path.join(odoo_config.customs_dir(), "migration.log")
    from_version = __safeget(command_parameters, 0, "Provide from version!")
    to_version = __safeget(command_parameters, 1, "Provide to version!")
    do_command("fix-permissions")
    do_migrate(
        LOGFILE,
        from_version,
        to_version,
        do_command,
        SETTINGS_D_FILE=os.path.join(dirs['settings.d'], 'migration'),
    )

def command_new_ticket(command_parameters, command_options):
    versioning.actions['new-ticket'](*command_parameters)

def command_open_tickets(comman_parameters, command_options):
    versioning.actions["open-tickets"](*command_parameters)

def command_patch(command_parameters, command_options):
    customs_dir = dirs['customs']
    odoo_dir = os.path.join(customs_dir, 'odoo')
    __assert_file_exists(odoo_dir, isdir=True)
    __system([
        'admin/odoo-patch'
    ] + command_parameters, cwd=dirs['odoo_home'], raise_exception=bool(command_parameters))  # otherwise show help
def command_prepare(command_parameters, command_options):
    print "All configurations prepared."
def command_progress(command_parameters, command_options):
    for row in __execute_sql("select state, count(*) from ir_module_module group by state;", fetchall=True):
        print "{}: {}".format(row[0], row[1])

def command_proxy_reload(command_parameters, command_options):
    if __is_container_running('proxy'):
        dcexec(['proxy', '/opt/bin/hot_reload.sh'])

def command_pull(command_parameters, command_options):
    submodule_name = __safeget(command_parameters, 0, "Please provide submodule name")
    __assert_file_exists(os.path.join(dirs['customs'], '.git'))
    __system([
        'git',
        'subtree',
        'pull',
        '--message',
        'SUBTREE-PULL {}'.format(submodule_name),
        '--prefix'
        'common/{}'.format(submodule_name),
        '--squash',
        'git.mt-software.de:"/git/openerp/modules/{}'.format(submodule_name),
        'master'
    ], cwd=dirs['customs'])

def command_pull_all(command_parameters, command_options):
    __assert_file_exists(os.path.join(dirs['customs'], '.git'))
    out = __system([
        'git',
        'log',
    ]).split('\n')
    out = filter(lambda line: 'git-subtree-dir:', out)
    out = map(lambda line: out.strip().split(": ")[1].strip(), out)
    for tree in out:
        __system([
            'git',
            'subtree',
            'pull',
            '-message',
            'SUBTREE-PULL {}'.format(tree),
            '--prefix="{}"'.format(tree),
            '--squash',
        ], cwd=dirs['customs'])

def command_push(command_parameters, command_options):
    submodule_name = __safeget(command_parameters, 0, "Please provide submodule name")
    __assert_file_exists(os.path.join(dirs['customs'], '.git'))

    __system([
        'git',
        'subtree',
        'push',
        '--prefix="common/{}"'.format(submodule_name),
        'git.mt-software.de:"/git/odoo/modules/{}"'.format(submodule_name),
        'master'
    ], cwd=dirs['customs'])

def command_rebuild(command_parameters, command_options):
    do_command("compose")
    dc(['build', '--no-cache'] + command_parameters)

def command_remove_web_assets(command_parameters, command_options):
    """
    if odoo-web interface is broken (css, js) then purging the web-assets helps;
    they are usually recreated when admin login
    """
    _askcontinue()
    from module_tools.module_tools import remove_webassets
    remove_webassets()
    if float(E("ODOO_VERSION")) <= 10.0:
        print("Please login as admin, so that assets are recreated.")

def command_reset_db(command_parameters, command_options):
    _askcontinue("Delete database {}".format(E("DBNAME")))
    if E("RUN_POSTGRES") != "1":
        print "Postgres container is disabled; cannot reset external database"
        return
    print "Stopping all services and creating new database"
    print "After creation the database container is stopped. You have to start the system up then."
    dc(['kill'])
    __reset_postgres_container()
    print "Database initialized."

def command_restart(command_parameters, command_options):
    dc(['stop'] + command_parameters)
    dc(['rm', '-f'] + command_parameters)
    dc(['up', '--force-recreate'] + command_parameters)
    do_command('proxy_reload')

def command_restore_dev_db(command_parameters, command_options):
    if E("ALLOW_RESTORE_DEV") != "1" and not FORCE:
        raise Exception("ALLOW_RESTORE_DEV must be explicitly allowed.")

    print("Restores dump to $DB_HOST and executes to scripts to adapt user passwords, mailservers and cronjobs")

    def exec_sql(dbname):
        __turn_into_devdb(dbname)

    do_command("restore-db", command_parameters, command_options={
        'exec_before_rename': exec_sql,
        'restore_as_dev_db': True,
    })

def command_restore_files(command_parameters, command_options):
    dumpfile = __safeget(command_parameters, 0, "Please provide dumpfile")
    if not command_parameters:
        raise Exception("Please provide the tar file-name.")
    __do_restore_files(dumpfile)

def command_restore_db(command_parameters, command_options):
    for x in ["DB_HOST", "DB_PORT"]:
        print("{}: {}".format(x, E(x)))
    dumpfile = __safeget(command_parameters, 0, "Please provide dump-file name", file_options=BACKUPDIR)
    dumpfile == os.path.join(BACKUPDIR, dumpfile)
    if dumpfile.startswith("/"):
        raise Exception("No path in dump file allowed")
    __restore_check(dumpfile)
    if E("DEVMODE") == "1" and not command_options.get('restore_as_dev_db', False):
        _askcontinue("DEVMODE ist set - really restore as normal db? Not using restore-dev-db?")

    if not FORCE:
        _askcontinue("Deletes database {}!".format(E("DBNAME")))

    DBNAME_RESTORING = E("DBNAME") + "_restoring"
    os.environ['DBNAME'] = DBNAME_RESTORING

    config = MyConfigParser(files['settings'])
    dbname = config['DBNAME']

    do_command('reset-db')
    __do_restore_db_on_postgres(dumpfile, DBNAME_RESTORING)
    if command_options.get("exec_before_rename", False):
        command_options['exec_before_rename'](DBNAME_RESTORING)
    __rename_db_drop_target(DBNAME_RESTORING, dbname)
    __remove_postgres_connections(dbname)
    __set_db_ownership()
    do_command('telegram-send', ["Database Restore $DBNAME done."])

def command_rm(command_parameters, command_options):
    dc(['rm'] + command_parameters)

def command_rmpyc(command_parameters, command_options):
    for root, _, _files in os.walk(dirs['customs']):
        for filename in _files:
            if filename.endswith(".pyc"):
                os.unlink(os.path.join(root, filename))

def command_run(command_parameters, command_options):
    __set_db_ownership()
    if len(command_parameters) == 2:
        if command_parameters[1] == 'bash':
            do_command("runbash")
            return
    dcrun(command_parameters)

def command_runbash(command_parameters, command_options):
    machine = __safeget(command_parameters, 0, "Please give machine name as second parameter e.g. postgres, odoo")
    __set_db_ownership()
    _display_machine_tips(machine)
    bash = _get_bash_for_machine(machine)
    cmd = __get_cmd() + ['run', machine, bash]
    os.system(" ".join(cmd))

def command_sanity_check(command_parameters, command_options):
    _sanity_check()

def command_set_db_ownership(command_parameters, command_options):
    __set_db_ownership()

def command_setup_startup(command_parameters, command_options):
    if os.path.exists("/sbin_host/initctl"):
        raise Exception("Not impl")
    else:
        print "Setting up systemd script for startup"
        servicename = os.path.expandvars("${CUSTOMS}_odoo.service")
        file = os.path.join("/tmp_host, servicename")

        # echo "Setting up upstart script in $file"
        shutil.copy(os.path.join(dirs['odoo_home'], 'config', 'systemd'), file)
        __replace_in_file(file, "${CUSTOMS}", E("CUSTOMS"))
        __replace_in_file(file, "${PATH}", E("HOST_ODOO_HOME"))

        print("Please execute on host now (perhaps as sudo):")
        print("""cp /tmp/{servicename} /etc/systemd/system")
        systemctl stop {servicename}
        systemctl disable {servicename}
        systemctl daemon-reload
        systemctl reset-failed
        systemctl enable {servicename}
        systemctl start {servicename}
        """.format(servicename=servicename)
              )

def command_show_install_state(command_parameters, command_options):
    rows = __execute_sql(
        "SELECT name, state from ir_module_module where state not in ('installed', 'uninstalled');",
        fetchall=True
    )
    print("Displaying dangling modules:")
    for row in rows:
        print("{}: {}".format(row[0], row[1]))

    if len(rows):
        raise Exception("Dangling modules detected - please fix installation problems and retry!")

def command_simplebash(command_parameters, command_options):
    if not command_parameters:
        os.system("bash --noprofile")
    else:
        os.system("bash --noprofile -c {}".format(" ".join(command_parameters)))

def command_springclean(command_parameters, command_options):
    os.system("docker system prune")
    print("removing dead containers")
    os.system('docker ps -a -q | while read -r id; do docker rm "$id"; done')

    print("Remove untagged images")
    os.system('docker images | grep "<none>" | awk \'{ print "docker rmi " $3 }\' | bash')

    print("delete unwanted volumes (can pass -dry-run)")
    os.system('docker images -q -f="dangling=true" | while read -r id; do docker rmi "$id"; done')

def command_stage(command_parameters, command_options):
    versioning.action_stage_ticket()

def command_stage_ticket(comman_parameters, command_options):
    versioning.actions["stage-ticket"](*command_parameters)

def command_stop(command_parameters, command_options):
    dc(['stop'] + command_parameters)

def command_submodule(command_parameters, command_options):
    __assert_file_exists(os.path.join(dirs['customs'], '.git'))
    __assert_file_exists(os.path.join(dirs['customs'], 'common'))

    for submodule in command_parameters:
        __system([
            'git',
            'subtree',
            'add',
            '--prefix="common/{}"'.format(submodule),
            '--squash',
            'git.mt-software.de:"/git/openerp/modules/{}"'.format(submodule),
            'master',
        ], cwd=dirs['customs'])

def command_switch_ticket(comman_parameters, command_options):
    versioning.actions["switch-ticket"](*command_parameters)

def command_telegram_setup(command_parameters, command_options):
    """
    helps creating a permanent chatid
    """
    if E("TELEGRAM_ENABLED") == "1":
        os.system("""
cd "{dir}"
docker-compose run -it telegrambat /setup.sh
""".format(dir=dirs['telegrambot']))

def command_telegram_send(command_parameters, command_options):
    if E("TELEGRAM_ENABLED") == "1":
        os.system("""
            cd "{dir}"
            docker-compose run telegrambat /send.py "{message}"
        """.format(
            dir=dirs['telegrambot'],
            message=__safeget(command_parameters, 0, "Please define message to send")
        ))

def command_test(command_parameters, command_options):
    print 'reached the command area'
    print os.path.expandvars("CUSTOMS is: $CUSTOMS")
    print os.path.expandvars("Here is pgpassfile: $PGPASSFILE")
    print "Now calling simple psql"
    __execute_sql("select state, count(*) from ir_module_module group by state;")

def command_test_make_error(command_parameters, command_options):
    print("now throwing exit code")
    sys.exit(123)
def command_turn_into_dev(command_parameters, command_options):
    if E("DEVMODE") != "1":
        raise Exception("""When applying this sql scripts, the database is not usable anymore for production environments.
Please set DEVMODE=1 to allow this""")
    __turn_into_devdb(E("DBNAME"))

def command_type(command_parameters, command_options):
    dump_file = __safeget(command_parameters, 0, "Please provide the dump name", file_options=BACKUPDIR)
    dump_file = os.path.join(BACKUPDIR, dump_file)
    print __get_dump_type(dump_file)

def command_update_ast(command_parameters, command_options):
    if _get_platform() == PLATFORM_OSX:
        print "Update is extreme slow on osx due to share performance. Please use following command natively:"
        print
        print
        print 'time PYTHONPATH=$ODOO_HOME/admin/module_tools python -c "from odoo_parser import update_cache; update_cache()"'
        print
        print
        sys.exit(2)
    started = datetime.now()
    print "Updating ast - can take about one minute; slow on OSX due to share"
    update_cache()
    print "Updated ast - took {} seconds".format((datetime.now() - started).seconds)

def command_up(command_parameters, command_options):
    __set_db_ownership()
    dc(['up'] + command_parameters)
    do_command("proxy-reload")

def command_update(command_parameters, command_options):
    """
    Just custom modules are updated, never the base modules (e.g. prohibits adding old stock-locations)
    Minimal downtime - but there is a downtime, even for phones
    """
    do_command('abort-upgrade')
    print("Run module update")
    if E("ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER") == "1":
        with open(E("ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER"), 'w') as f:
            f.write(datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

    # running duplicate updates is really a problem;
    do_command('kill')
    dc(['rm', '-f'])
    dc(['create', '--force-recreate'])
    __start_postgres_and_wait()

    module = command_parameters[0] if command_parameters else ""
    try:
        dcrun(['odoo_update', '/update_modules.sh', module])
    except Exception:
        raise Exception("Error at /update_modules.sh - aborting update process.")
    do_command('show-install-state')

    for i in range(5):
        dc(['up', '-d'])
        do_command('proxy-reload')
        time.sleep(2)

    os.system('df -h /') # case: after update disk / was full
    if E("ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER") == "1":
        with open(E("ODOO_UPDATE_START_NOTIFICATION_TOUCH_FILE_IN_CONTAINER"), 'w') as f:
            f.write("0")
    do_command('telegram-send', ["Update done"])

def command_versioning(command_parameters, command_options):
    versioning.actions[command_parameters[0]](*command_parameters[1:])

def command_wait_for_container_postgres(command_parameters, command_options):
    __start_postgres_and_wait()

def command_wait_for_port(command_parameters, command_options):
    host = command_parameters[0]
    port = long(command_parameters[1])
    __wait_for_port(host=host, port=port)

def do_command(command, command_parameters=[], command_options={}):
    command = command.replace("-", "_")
    if command in commands:
        return commands[command](command_parameters, command_options)
    else:
        raise Exception("Unknown Command: {} {}".format(command, " ".join(command_parameters)))

def command_psql(command_parameters, command_options):
    if not command_parameters:
        command_parameters = [E("DBNAME")]
    params = " ".join(command_parameters)
    os.system("psql " + params)


for x, v in globals().items():
    if x.startswith('command_') and v.__call__:
        x = x[len("command_"):]
        commands[x] = v

if __name__ == '__main__':
    _startup()
    _check_working_dir_customs_mismatch
    if args:
        if args[0] == 'tool':
            sys.exit(0)

    _export_settings()
    _remember_customs_and_cry_if_changed
    if not args:
        _showhelp()
        sys.exit(0)
    _sanity_check()

    try:
        command_parameters = args[1:] if len(args) > 1 else []
        do_command(args[0], command_parameters)
        pass
    finally:
        _cleanup
