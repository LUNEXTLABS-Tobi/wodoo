#!/usr/bin/python
# -*- coding: utf-8 -*-
# Parameter:
# $1: name of customization
# To be called by odoo link

import threading
import os
import sys
import glob
import shutil
from module_tools.consts import MANIFESTS
from module_tools.odoo_config import current_customs
from module_tools.odoo_config import customs_dir
from module_tools.odoo_config import current_version
from module_tools.module_tools import get_module_of_file
from module_tools.odoo_parser import is_module_of_version

LN_DIR = os.path.join(customs_dir(), 'links')
IGNORE_PATHS = ['odoo/addons', 'odoo/odoo/test']
if not os.path.isdir(LN_DIR):
    os.mkdir(LN_DIR)
counter = 0
version = current_version()
print "Linking all modules into: \n{}".format(LN_DIR)
all_valid_module_paths = []

for link in os.listdir(LN_DIR):
    os.unlink(os.path.join(LN_DIR, link))

os.system("chown $ODOO_USER:$ODOO_USER \"{}\"".format(LN_DIR))

def search_dir_for_modules(base_dir):
    global counter

    def link_module(complete_module_dir):
        global counter
        if version >= 11.0:
            if not os.path.exists(os.path.join(complete_module_dir, '__manifest__.py')):
                return
            abs_root = os.path.abspath(base_dir)
            dir = os.path.abspath(complete_module_dir)
            module_name = get_module_of_file(complete_module_dir)
            target = os.path.join(LN_DIR, module_name)
            if os.path.exists(target):
                if os.path.realpath(target) != complete_module_dir:
                    # let override OCA modules
                    if "/OCA/" in os.path.realpath(target):
                        os.unlink(target)
                    elif "/OCA/" in complete_module_dir:
                        os.unlink(target)
                    else:
                        raise Exception("Module {} already linked to {}; could not link to {}".format(os.path.basename(target), os.path.realpath(target), complete_module_dir))
            rel_path = complete_module_dir.replace(customs_dir(), "../active_customs")
            os.symlink(rel_path, target)
            counter += 1

        else:
            # prüfen, obs nicht zu den verbotenen pfaden gehört:
            abs_root = os.path.abspath(base_dir)
            dir = os.path.abspath(complete_module_dir)
            while dir != abs_root:
                dir = os.path.abspath(os.path.join(dir, ".."))

            try:
                module_name = get_module_of_file(complete_module_dir)
            except Exception:
                return

            target = os.path.join(LN_DIR, module_name)

            if os.path.exists(target):
                if os.path.realpath(target) != complete_module_dir:
                    # let override OCA modules
                    if "/OCA/" in os.path.realpath(target):
                        os.unlink(target)
                    elif "/OCA/" in complete_module_dir:
                        os.unlink(target)
                    else:
                        raise Exception("Module {} already linked to {}; could not link to {}".format(os.path.basename(target), os.path.realpath(target), complete_module_dir))

            # if there are versions under the module e.g. 6.1, 7.0 then take name from parent
            try:
                float(os.path.basename(target))
                target = os.path.dirname(target)
                target += "/%s" % os.path.basename(os.path.dirname(complete_module_dir))
            except Exception:
                pass

            while os.path.islink(target):
                os.unlink(target)

            rel_path = complete_module_dir.replace(customs_dir(), "../active_customs")
            os.symlink(rel_path, target)
            counter += 1

    def visit(root, dir, files):
        if '/.git/' in dir:
            return
        if '__pycache__' in dir:
            return
        if any(x in dir for x in IGNORE_PATHS):
            return
        if not is_module_of_version(dir):
            return
        all_valid_module_paths.append(dir)

    os.path.walk(base_dir, visit, False)

    def sort_paths(x):
        if '/OCA/' in x:
            return "0000_" + x
        return "1000_" + x

    for path in sorted(all_valid_module_paths, key=sort_paths):
        link_module(path)


search_dir_for_modules(customs_dir())

print "linked {} modules".format(counter)
