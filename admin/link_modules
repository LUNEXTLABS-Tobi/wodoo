#!/usr/bin/python
# -*- coding: utf-8 -*-
# Parameter:
# $1: name of customization

import threading
import os
import sys
import glob
import shutil
from module_tools.consts import MANIFESTS
from module_tools.odoo_config import current_customs
from module_tools.odoo_config import customs_dir
from module_tools.odoo_config import current_version

LN_DIR = os.environ['ADDONS_CUSTOMS']
counter = 0
version = current_version()
print "Linking all modules into: \n{}".format(LN_DIR)

if os.path.isdir(LN_DIR):
    shutil.rmtree(LN_DIR, ignore_errors=True)
os.makedirs(LN_DIR)
os.system("chown $ODOO_USER:$ODOO_USER \"{}\"".format(LN_DIR))

def search_dir_for_modules(base_dir):

    ommitted_directories_full_path = []

    def link_module(complete_module_dir):

        # prÃ¼fen, obs nicht zu den verbotenen pfaden gehÃ¶rt:
        abs_root = os.path.abspath(base_dir)
        dir = os.path.abspath(complete_module_dir)
        while dir != abs_root:
            if dir in ommitted_directories_full_path:
                return
            dir = os.path.abspath(os.path.join(dir, ".."))

        target = os.path.join(LN_DIR, os.path.basename(complete_module_dir))

        if os.path.exists(target):
            if os.path.realpath(target) != complete_module_dir:
                # let override OCA modules
                if "/OCA/" in os.path.realpath(target):
                    os.unlink(target)
                elif "/OCA" in complete_module_dir:
                    return
                else:
                    raise Exception("Module {} already linked to {}; could not link to {}".format(os.path.basename(target), os.path.realpath(target), complete_module_dir))

        # if there are versions under the module e.g. 6.1, 7.0 then take name from parent
        try:
            float(os.path.basename(target))
            target = os.path.dirname(target)
            target += "/%s" % os.path.basename(os.path.dirname(complete_module_dir))
        except:
            pass

        while os.path.islink(target):
            os.unlink(target)

        try:
            try:
                os.symlink(complete_module_dir, target)
            except:
                print u"failed: {} {}".format(complete_module_dir, target)
                raise
            global counter
            counter += 1
        except:
            print 'Fehlgeschlagen symbolischer Link %s - %s' % (complete_module_dir, target)
            raise

    def is_module_dir_in_version(module_dir):
        result = {'ok': False, "paths": []}
        info_file = os.path.join(module_dir, ".ln")
        if os.path.exists(info_file):
            with open(info_file, 'r') as f:
                content = f.read()
            try:
                info = eval(content)
            except:
                print "error at file: %s" % info_file
                raise
            if isinstance(info, (float, long, int)):
                min_ver = info
                max_ver = info
                info = {'minimum_version': min_ver, 'maximum_version': max_ver}
            else:
                min_ver = info.get("minimum_version", 1.0)
                max_ver = info.get("maximum_version", 1000.0)
            if min_ver > max_ver:
                raise Exception("Invalid version: {}".format(module_dir))
            if float(version) >= float(min_ver) and float(version) <= float(max_ver):
                result['ok'] = True

            for m in MANIFESTS:
                if os.path.exists(os.path.join(module_dir, m)):
                    result['paths'].append(module_dir)
            if info.get('paths') and result['ok']:
                # used for OCA paths for example
                for path in info['paths']:
                    path = os.path.abspath(os.path.join(module_dir, path))
                    result['paths'].append(path)
        elif "/OCA/" in module_dir:
            relpath = module_dir.split(u"/OCA/")[1].split("/")
            if len(relpath) == 2:
                return {
                    'ok': True,
                    'paths': [module_dir],
                }

        return result

    def visit(arg, dirname, names):
        in_version = is_module_dir_in_version(dirname)
        if not in_version['ok']:
            return

        try:
            for path in in_version['paths']:
                if ".git" in path:
                    continue
                link_module(path)
        except:
            print "Fehler in %s" % dirname
            raise

    os.path.walk(base_dir, visit, False)


search_dir_for_modules(customs_dir())

print "linked {} modules".format(counter)
