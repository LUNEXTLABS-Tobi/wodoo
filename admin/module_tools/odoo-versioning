#!/usr/bin/python
"""
Manages versioning of submodules.

"""
import sys
import subprocess
import module_tools
from module_tools import get_all_non_odoo_modules
from module_tools import get_module_of_file
from module_tools import get_relative_path_to_odoo_module
from module_tools import write_manifest
from module_tools import manifest2dict
from odoo_config import translate_path_relative_to_customs_root
import odoo_config
import shutil
import datetime
import os
import time
import tempfile
from git import Repo
from git import Actor
from myconfigparser import MyConfigParser
import inspect
current_file = os.path.abspath(inspect.getfile(inspect.currentframe())) # script directory

if len(sys.argv) >= 2:
    action = sys.argv[1]
else:
    action = None

customs_dir = odoo_config.customs_dir()

def display_help():
    print "How to use:"
    print ""
    print "$0 new-ticket <ticketname>"
    print "$0 unit-test"
    print "$0 help"
    print "$0 dirty - displays dirty files and modules"
    print "$0 merge master/deploy - to merge ticket to master or deploy branch"
    print ""
    print ""
    sys.exit(-1)

def check_dirty(repo):
    dirty = bool(repo.is_dirty() or repo.untracked_files)

    if dirty:
        print "Please clean-up before - it is dirty here:"
        os.chdir(customs_dir)
        os.system("git status")
        sys.exit(13)

def domerge():
    branch = sys.argv[2]

    if branch not in ['master', 'deploy']:
        print "Please say wether master or deploy"
        sys.exit(1)
    repo = Repo(customs_dir)
    check_dirty(repo)

    active_branch = repo.active_branch.name
    if active_branch == 'master':
        print "Cant merge master on deploy - use the sub branches to merge on deploy"
        sys.exit(84)

    SQUASH = '--squash'
    subprocess.check_call(['/usr/bin/git', 'checkout', '-f', branch], cwd=customs_dir)
    subprocess.check_call(['/usr/bin/git', 'merge', SQUASH, active_branch], cwd=customs_dir)
    subprocess.check_call(['/usr/bin/git', 'commit', '-am', 'merged {} into {}'.format(active_branch, branch)], cwd=customs_dir)

def action_new_ticket():
    repo = Repo(customs_dir)
    check_dirty(repo)
    if action in ['new-ticket'] and len(sys.argv) < 3:
        print "Please provide ticket name!"
        sys.exit(-1)

    repo = Repo(customs_dir)

    branch = sys.argv[2]
    if [x for x in repo.branches if x.name == branch]:
        print "Branch already exists, switching to it"
        subprocess.check_call(['/usr/bin/git', 'checkout', '-f', branch], cwd=customs_dir)
    else:
        subprocess.check_call(['/usr/bin/git', 'checkout', '-f', 'deploy'], cwd=customs_dir)
        subprocess.check_call(['/usr/bin/git', 'checkout', '-b', branch], cwd=customs_dir)

def dirty(doprint=True, interactive=True):
    repo = Repo(customs_dir)
    bool(repo.is_dirty() or repo.untracked_files)

    def get_changed_files():
        return [item.a_path for item in repo.index.diff(None)] + repo.untracked_files

    def get_staged_files():
        return [x.a_path for x in repo.index.diff("HEAD")]

    def unstage():
        for file in get_staged_files():
            repo.git.reset(file)

    unstage()
    changed_files = get_changed_files()

    affected_modules = []
    for mod in sorted(get_all_non_odoo_modules(return_relative_manifest_paths=True)):
        module_path = os.path.dirname(mod)

        files = [x for x in changed_files if x.startswith(module_path)]
        if files:
            affected_modules.append(module_path)
            [changed_files.remove(x) for x in files]

    if doprint:
        if affected_modules:
            print ""
            print "Modules:"
            print "----------------------------------"
            for mod in affected_modules:
                print "module {}\t[{}]".format(get_module_of_file(mod), mod)

        if changed_files:
            print ""
            print "Other:"
            for file in changed_files:
                print file

    def rungitcola(path):
        os.chdir(customs_dir)
        os.system('git-cola >/dev/null 2>&1 &')
        time.sleep(1.0)
        os.system('/usr/bin/pkill -9 -f git-cola')
        os.system('git-cola >/dev/null 2>&1')

    def get_modified_files_of_module(manifest_path):
        changed_files = get_changed_files()
        module_path = os.path.dirname(manifest_path)

        module_files = [x for x in changed_files if x.startswith(module_path)]
        return module_files

    def insert_changelog(readme_path, changelog):
        """
        Inserts into readme_path the change log
        """
        with open(readme_path) as f:
            content = f.read().split("\n")

        content += "\n"
        content += datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC") + "\n"
        content += "========================================"
        content += changelog

        with open(readme_path, 'w') as f:
            f.write('\n'.join(content))

    def do_interactive_commit(changed_files, manifest_path):
        for x in changed_files:
            repo.git.add(x)
        print "Changed files detected, i put them on stage; please select/deselect for stage"
        print "Just close git-cola - DO NOT COMMIT YET"
        time.sleep(1)
        rungitcola(customs_dir)
        files = get_staged_files()
        if not files:
            user = raw_input("No files staged - try again? Otherwise abort. [y]/[N]")
            if user.lower() == 'n':
                sys.exit(0)
                return
        print ""
        print "On Stage:"
        for file in files:
            print "\t{}".format(file)

        while True:
            user = raw_input("[B]ugfix, [F]eature, [C]ancel?")
            if not user or user.lower() in ['c', 'b', 'f']:
                break

        if user.lower() == 'c':
            sys.exit(0)

        type = user.upper()

        lines = []
        print "Please describe, what was done. To finish type 'done' and hit return: (Ctrl+C to abort)\n\n"
        while True:
            try:
                text = raw_input("")
            except:
                EOFError
                break
            if text == 'done':
                break
            lines.append(text)
        text = '\n'.join(lines)

        format_msg = "{}@{}\n\n{}".format(
            'BUGFIX' if type == 'B' else 'FEATURE',
            get_module_of_file(os.path.join(customs_dir, manifest_path)) if manifest_path else "",
            text
        )

        # on module update increment the version:
        if manifest_path:
            d = manifest2dict(os.path.join(customs_dir, manifest_path))
            module_name, module_path = get_module_of_file(os.path.join(customs_dir, manifest_path), return_path=True)

            v = d['version']
            v = v.split('.')
            if len(v) == 2:
                v.append('0')
            if type == 'B':
                v[-1] = long(v[-1]) + 1
            elif type == 'F':
                v[-2] = long(v[-2]) + 1
            else:
                raise Exception("Not implemented: {}".format(type))
            v = '.'.join(str(x) for x in v)
            d['version'] = v
            write_manifest(os.path.join(customs_dir, manifest_path), d)

            README_PATH = os.path.join(module_path, 'README.rst')
            if os.path.isfile(README_PATH):
                insert_changelog(README_PATH, format_msg)
                repo.git.add(README_PATH)

            repo.git.add(manifest_path)

        author = Actor(os.environ['USER'], os.environ['USER'])
        repo.index.commit(format_msg, author=author, committer=author)

        print "Successfully commited: \n\n".format(format_msg)
        time.sleep(1)

        if '/common/' in manifest_path:
            while True:
                user = input("Try to push subtree? [Y/n]") or 'y'
                if user.lower() in 'yn':
                    break
            if user == 'y':
                # TODO
                pass

        new_changed_files = [x for x in get_changed_files() if x in changed_files]
        return new_changed_files

    if interactive and (changed_files or affected_modules):
        print ""
        user_commit = raw_input("Going to commit? [Y/n] ")
        if user_commit.lower() == 'n':
            sys.exit(0)

        while changed_files:
            changed_files = do_interactive_commit(changed_files, manifest_path=None)

        for module in affected_modules:
            changed_files = get_modified_files_of_module(module)
            if not changed_files:
                continue
            while changed_files:
                module_name, module_path, manifest_path = get_module_of_file(os.path.join(customs_dir, changed_files[0]), return_manifest=True)
                manifest_path = translate_path_relative_to_customs_root(manifest_path)
                changed_files = do_interactive_commit(changed_files, manifest_path=manifest_path)

def unit_tests_git():
    r = {
    }

    def reset_repo():
        global repo

        path = tempfile.mkdtemp(suffix='')

        path_repo = os.path.join(path, 'repo1')
        print path_repo
        os.mkdir(path_repo)

        repo = Repo.init(path_repo, bare=False)
        print repo.is_dirty()
        file1 = os.path.join(path_repo, 'file1.txt')
        with open(file1, 'w') as f:
            f.write("1")
        r['repo'] = repo
        r['file1'] = file1
        r['author'] = Actor("User1", "user1@home.de")

        r['path_subrepo'] = os.path.join(path, 'subrepo')
        r['subrepo'] = Repo.init(r['path_subrepo'])
        file1 = os.path.join(r['path_subrepo'], 'subfile1.txt')
        with open(file1, 'w') as f:
            f.write("sub 1")

    def case1():
        "commit a file"
        global repo
        reset_repo()
        repo = r['repo']
        file1 = r['file1']
        assert len(repo.untracked_files) == 1
        changed_files = [item.a_path for item in repo.index.diff(None)]
        #staged_files = [item.a_path for item in repo.index.diff("HEAD")]
        repo.index.add([os.path.basename(file1)])
        repo.index.commit("msg1", author=r['author'], committer=r['author'])
        #repo.git.add(update=True) # no new files

        with open(file1, 'w') as f:
            f.write("2")
        changed_files = [item.a_path for item in repo.index.diff(None)]
        repo.index.add(changed_files)
        repo.index.commit("msg2", author=r['author'], committer=r['author'])

        file2 = os.path.join(repo.working_dir, 'file2.txt')
        with open(file2, 'w') as f:
            f.write("3")
        assert len(repo.untracked_files) == 1
        repo.index.add(repo.untracked_files)
        repo.index.commit("msg3", author=r['author'], committer=r['author'])

        os.unlink(file2)

        # caution: commit updates and deletes by directory
        # TODO extract following code
        for diff in repo.index.diff(None):
            if not diff.b_mode and not diff.b_blob:
                # deleted
                repo.index.remove(items=[diff.a_path])
            else:
                repo.index.add(items=[diff.a_path])
        repo.index.commit("deleted", author=r['author'], committer=r['author'])

    def case_empty_commit():
        global repo
        reset_repo()
        repo = r['repo']
        file1 = r['file1']
        repo.index.add([os.path.basename(file1)])
        repo.index.commit("msg1", author=r['author'], committer=r['author'])

        # now empty commit
        repo.index.commit("msg empty")

    def case_submodule():
        global repo
        reset_repo()
        repo = r['repo']
        file1 = r['file1']
        assert len(repo.untracked_files) == 1
        changed_files = [item.a_path for item in repo.index.diff(None)]
        #staged_files = [item.a_path for item in repo.index.diff("HEAD")]
        repo.index.add([os.path.basename(file1)])
        repo.index.commit("msg1", author=r['author'], committer=r['author'])

        #clone submodule
        subrepo_dir = 'subrepo'
        repo.clone_from(r['path_subrepo'], os.path.join(repo.working_dir, subrepo_dir))

        repo.index.commit("subrepo added")

    #case1()
    #case_empty_commit()
    case_submodule()

def unit_tests():
    # make new customs
    customs = 'vunittest'

    customs_dir = os.path.join(odoo_config.customs_root(), customs)
    assert '/' + customs in customs_dir, customs_dir

    def make_module(parent_path, modulename):
        os.chdir(parent_path)
        for v in ['7.0', '9.0']:
            subprocess.check_call('mkdir -p "{modulename}/{v}"'.format(**locals()), cwd=parent_path, shell=True)
            with open('{modulename}/{v}/__openerp__.py'.format(**locals()), 'w') as f:
                f.write("{'version': '1.0'}")

    def make_demo_customs(path):
        if os.path.exists(customs_dir):
            shutil.rmtree(customs_dir)
        os.makedirs(customs_dir)
        os.chdir(customs_dir)
        os.system("git init .")
        os.system('mkdir -p common')
        os.system('mkdir -p modules')

        with open(os.path.join(customs_dir, '.version'), 'w') as f:
            f.write("9.0")
        with open(os.path.join(customs_dir, '.odoo.ast'), 'w') as f:
            f.write("")

        # make submodule
        path_modules1 = tempfile.mkdtemp()
        os.chdir(path_modules1)
        make_module(path_modules1, 'submodule1_1')
        make_module(path_modules1, 'submodule1_2')
        make_module(path_modules1, 'submodule1_3')
        make_module(os.path.join(customs_dir, 'modules'), 'module1')
        subprocess.check_call("git init .", cwd=path_modules1, shell=True)
        subprocess.check_call("git add .; git commit -am .", cwd=path_modules1, shell=True)

        # clone submodules into common
        os.chdir(customs_dir)
        subprocess.check_call('git clone "{}" common/submodule1'.format(path_modules1), cwd=customs_dir, shell=True)

    def v(*params):
        cmd = [current_file] + list(params)
        subprocess.check_call(cmd, cwd=customs_dir)

    make_demo_customs(customs_dir)
    odoo_config.set_customs(customs)
    # make demo customs

    print 'Start working on a new ticket - customers ticket number is ticket#1'
    v('new-ticket', 'ticket#1')
    v('new-ticket', 'ticket#2')


actions = {
    'new-ticket': action_new_ticket,
    'unit-test': unit_tests,
    'unit-tests': unit_tests,
    'unit-tests-git': unit_tests_git,
    'help': display_help,
    'dirty': dirty,
    'merge': domerge,
}


if action not in actions:
    print "Invalid verb: {}".format(action)
    display_help()
    sys.exit(-1)
else:
    actions[action]()
